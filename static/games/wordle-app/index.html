<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Wordle</title>
    <style>
        :root {
            --correct: #6aaa64;
            --present: #c9b458;
            --absent: #787c7e;
            --default-border: #d3d6da;
            --filled-border: #878a8c;
            --bg: #ffffff;
            --text: #000000;
            --key-bg: #d3d6da;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #121213;
                --text: #ffffff;
                --default-border: #3a3a3c;
                --filled-border: #565758;
                --key-bg: #818384;
            }
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border-bottom: 1px solid var(--default-border);
            width: 100%;
            gap: 10px;
        }

        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; }

        select {
            padding: 5px;
            font-size: 1rem;
            border-radius: 5px;
        }

        button.restart-btn {
            padding: 5px 10px;
            cursor: pointer;
            background: var(--correct);
            color: white;
            border: none;
            border-radius: 4px;
        }

        #game-board {
            display: grid;
            grid-gap: 5px;
            padding: 10px;
            box-sizing: border-box;
            flex-grow: 1;
            align-content: center;
            max-height: 65vh;
        }

        .tile {
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 2px solid var(--default-border);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            user-select: none;
        }

        /* åŠ¨æ€è°ƒæ•´æ ¼å­å¤§å°ï¼Œé˜²æ­¢å¤ªå°æˆ–å¤ªå¤§ */
        @media (max-height: 600px) { .tile { font-size: 1.5rem; } }

        .tile[data-state='active'] { border-color: var(--filled-border); animation: pop 0.1s; }
        .tile[data-state='correct'] { background-color: var(--correct); border-color: var(--correct); color: white; }
        .tile[data-state='present'] { background-color: var(--present); border-color: var(--present); color: white; }
        .tile[data-state='absent'] { background-color: var(--absent); border-color: var(--absent); color: white; }
        
        /* ç¿»è½¬åŠ¨ç”» */
        .tile.flip { animation: flip 0.5s ease forwards; }

        @keyframes pop { 50% { transform: scale(1.1); } }
        @keyframes flip {
            0% { transform: rotateX(0); }
            50% { transform: rotateX(90deg); }
            100% { transform: rotateX(0); }
        }

        #keyboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding-bottom: 20px;
            width: 100%;
            max-width: 500px;
        }

        .keyboard-row { display: flex; gap: 6px; width: 95%; justify-content: center; }
        .key {
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            text-transform: uppercase;
            background-color: var(--key-bg);
            color: var(--text); /* é€‚é…æ·±è‰²æ¨¡å¼æ–‡å­— */
            height: 58px;
            flex: 1;
            font-size: 1.2rem;
            user-select: none;
        }
        .key[data-key='Enter'], .key[data-key='Backspace'] { flex: 1.5; font-size: 0.8rem; }
        .key[data-state='correct'] { background-color: var(--correct); color: white; }
        .key[data-state='present'] { background-color: var(--present); color: white; }
        .key[data-state='absent'] { background-color: var(--absent); color: white; }

        #message-container {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        .message {
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .loading { opacity: 0.5; pointer-events: none; }
    </style>
</head>
<body>

<header>
    <select id="length-selector">
        <option value="3">3 å­—æ¯</option>
        <option value="4">4 å­—æ¯</option>
        <option value="5" selected>5 å­—æ¯</option>
        <option value="6">6 å­—æ¯</option>
        <option value="7">7 å­—æ¯</option>
    </select>
    <h1>WORDLE</h1>
    <button class="restart-btn" onclick="startNewGameRound()">é‡ç½®</button>
</header>

<div id="message-container"></div>

<div id="game-board"></div>

<div id="keyboard">
    <div class="keyboard-row" id="row-1"></div>
    <div class="keyboard-row" id="row-2"></div>
    <div class="keyboard-row" id="row-3"></div>
</div>

<script>
    // --- é…ç½®åŒº ---
    const KEYS = [
        ['q','w','e','r','t','y','u','i','o','p'],
        ['a','s','d','f','g','h','j','k','l'],
        ['Enter','z','x','c','v','b','n','m','Backspace']
    ];
    
    let TARGET_WORDS = {
        3: ["cat", "dog", "sun", "run", "sky"],
        4: ["book", "love", "hope", "code", "data"],
        5: ["apple", "world", "hello", "smile", "happy"],
        6: ["planet", "friend", "banana", "orange", "guitar"],
        7: ["freedom", "journey", "history", "mystery", "silence"]
    };

    let wordLength = 5;
    let maxGuesses = 6; 
    let currentTarget = "";
    let currentRow = 0;
    let currentTile = 0;
    let isGameOver = false;
    let isLoading = false; 
    let guesses = []; 
    
    // æ¸¸æˆå®ä¾‹ ID
    let currentGameId = 0; 

    // --- åˆå§‹åŒ– ---
    const board = document.getElementById('game-board');
    const lengthSelector = document.getElementById('length-selector');

    // ç›‘å¬é•¿åº¦å˜åŒ–
    lengthSelector.addEventListener('change', (e) => {
        wordLength = parseInt(e.target.value);
        e.target.blur(); // ç§»å‡ºç„¦ç‚¹
        startNewGameRound(); 
    });

    // åŠ è½½è¯åº“
    async function loadWordsAndStart() {
        showMessage("æ­£åœ¨åŠ è½½è¯åº“...", 0);
        const msgContainer = document.getElementById('message-container');
        
        try {
            const response = await fetch('./words.txt');
            if (!response.ok) throw new Error("Network response was not ok");
            const text = await response.text();
            const allWords = text.split('\n')
                .map(w => w.trim().toLowerCase())
                .filter(w => w && /^[a-z]+$/.test(w));

            const newWordList = { 3: [], 4: [], 5: [], 6: [], 7: [] };
            let count = 0;
            allWords.forEach(word => {
                const len = word.length;
                if (newWordList[len]) {
                    newWordList[len].push(word);
                    count++;
                }
            });

            msgContainer.innerHTML = ''; 
            if (count > 0) {
                TARGET_WORDS = newWordList;
                showMessage("è¯åº“åŠ è½½å®Œæˆï¼", 1000);
            } else {
                showMessage("è¯åº“ä¸ºç©ºï¼Œä½¿ç”¨é»˜è®¤è¯åº“", 2000);
            }
        } catch (error) {
            console.error("åŠ è½½ words.txt å¤±è´¥:", error);
            msgContainer.innerHTML = ''; 
            showMessage("è¯åº“åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤è¯åº“", 2000);
        }

        createKeyboard();
        startNewGameRound();
    }

    function startNewGameRound() {
        // ğŸ”¥ å…³é”®ä¿®å¤ 1ï¼šå¼ºåˆ¶è®©å½“å‰è·å¾—ç„¦ç‚¹çš„å…ƒç´ ï¼ˆæ¯”å¦‚é‡ç½®æŒ‰é’®ï¼‰å¤±å»ç„¦ç‚¹
        // è¿™æ ·æŒ‰ä¸‹ Enter å°±ä¸ä¼šå†æ¬¡è§¦å‘å®ƒäº†
        if (document.activeElement instanceof HTMLElement) {
            document.activeElement.blur();
        }

        if (!TARGET_WORDS[wordLength] || TARGET_WORDS[wordLength].length === 0) {
            alert(`æŠ±æ­‰ï¼Œè¯åº“ä¸­æ²¡æœ‰é•¿åº¦ä¸º ${wordLength} çš„å•è¯ï¼`);
            return;
        }
        initGame();
    }

    // åˆ›å»ºé”®ç›˜
    function createKeyboard() {
        const rows = ['row-1', 'row-2', 'row-3'];
        rows.forEach((rowId, index) => {
            const rowEl = document.getElementById(rowId);
            rowEl.innerHTML = '';
            KEYS[index].forEach(key => {
                const button = document.createElement('div');
                button.textContent = key === 'Backspace' ? 'âŒ«' : key;
                button.classList.add('key');
                button.setAttribute('data-key', key);
                button.addEventListener('click', (e) => {
                    e.target.blur(); // ç‚¹å‡»è™šæ‹Ÿé”®ç›˜ä¹Ÿè¦ç§»å‡ºç„¦ç‚¹
                    handleInput(key);
                });
                rowEl.appendChild(button);
            });
        });
    }

    function initGame() {
        currentGameId++;

        maxGuesses = wordLength + 1;
        currentRow = 0;
        currentTile = 0;
        isGameOver = false;
        isLoading = false; 
        document.body.classList.remove('loading'); 
        guesses = Array(maxGuesses).fill(null).map(() => Array(wordLength).fill(''));
        
        board.innerHTML = '';
        document.getElementById('message-container').innerHTML = ''; 
        document.querySelectorAll('.key').forEach(k => k.removeAttribute('data-state')); 
        
        const list = TARGET_WORDS[wordLength];
        currentTarget = list[Math.floor(Math.random() * list.length)].toLowerCase();
        console.log("Target:", currentTarget); 

        board.style.gridTemplateColumns = `repeat(${wordLength}, 1fr)`;
        board.style.width = `${wordLength * 60}px`; 
        board.style.maxWidth = '95%';

        for (let i = 0; i < maxGuesses * wordLength; i++) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.id = `tile-${Math.floor(i / wordLength)}-${i % wordLength}`;
            board.appendChild(tile);
        }
    }

    function handleInput(key) {
        if (isGameOver || isLoading) return;

        if (key === 'Backspace') {
            if (currentTile > 0) {
                currentTile--;
                const tile = document.getElementById(`tile-${currentRow}-${currentTile}`);
                if(tile) {
                    tile.textContent = '';
                    tile.removeAttribute('data-state');
                    guesses[currentRow][currentTile] = '';
                }
            }
        } else if (key === 'Enter') {
            if (currentTile === wordLength) {
                checkGuess();
            } else {
                showMessage('å•è¯é•¿åº¦ä¸å¤Ÿ');
                shakeRow();
            }
        } else {
            if (currentTile < wordLength && /^[a-z]$/i.test(key)) {
                const tile = document.getElementById(`tile-${currentRow}-${currentTile}`);
                if(tile) {
                    tile.textContent = key;
                    tile.setAttribute('data-state', 'active');
                    guesses[currentRow][currentTile] = key.toLowerCase();
                    currentTile++;
                }
            }
        }
    }

    // ğŸ”¥ å…³é”®ä¿®å¤ 2ï¼šå…¨å±€é”®ç›˜ç›‘å¬ä¼˜åŒ–
    document.addEventListener('keydown', (e) => {
        // å¦‚æœæŒ‰ä¸‹çš„æ˜¯åŠŸèƒ½é”®ç»„åˆï¼Œä¸å¤„ç†
        if (e.ctrlKey || e.metaKey || e.altKey) return;

        let key = e.key;

        // å¦‚æœæ˜¯ Enter é”®ï¼Œé˜»æ­¢é»˜è®¤è¡Œä¸ºï¼ˆé˜²æ­¢è§¦å‘æŒ‰é’®ç‚¹å‡»ï¼‰
        if (key === 'Enter') {
            e.preventDefault(); 
            handleInput(key);
            return;
        }
        
        // Backspace ä¹Ÿè¦é˜²æ­¢æµè§ˆå™¨åé€€ï¼ˆè™½ç„¶ç°ä»£æµè§ˆå™¨å¾ˆå°‘é»˜è®¤åé€€äº†ï¼Œä½†ä»¥é˜²ä¸‡ä¸€ï¼‰
        if (key === 'Backspace') {
            handleInput(key);
            return;
        }

        if (/^[a-zA-Z]$/.test(key)) {
            handleInput(key.toLowerCase());
        }
    });

    async function checkGuess() {
        const thisRoundId = currentGameId;
        const guessWord = guesses[currentRow].join('');
        
        isLoading = true;
        document.body.classList.add('loading');
        
        const isValid = await validateWord(guessWord);
        
        if (thisRoundId !== currentGameId) return;

        document.body.classList.remove('loading');
        isLoading = false;

        if (!isValid) {
            showMessage('ä¸æ˜¯åˆæ³•çš„å•è¯');
            shakeRow();
            return;
        }

        flipTiles(guessWord, thisRoundId);
    }

    async function validateWord(word) {
        if (word === currentTarget) return true; 
        try {
            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            return response.ok; 
        } catch (error) {
            return true; 
        }
    }

    function flipTiles(guessWord, roundId) {
        const rowTiles = [];
        for (let i = 0; i < wordLength; i++) {
            rowTiles.push(document.getElementById(`tile-${currentRow}-${i}`));
        }

        const targetChars = currentTarget.split('');
        const guessChars = guessWord.split('');
        const states = Array(wordLength).fill('absent');

        guessChars.forEach((char, i) => {
            if (char === targetChars[i]) {
                states[i] = 'correct';
                targetChars[i] = null; 
                guessChars[i] = null;
            }
        });

        guessChars.forEach((char, i) => {
            if (char !== null && targetChars.includes(char)) {
                states[i] = 'present';
                targetChars[targetChars.indexOf(char)] = null; 
            }
        });

        rowTiles.forEach((tile, i) => {
            setTimeout(() => {
                if (roundId !== currentGameId) return;

                tile.classList.add('flip');
                tile.setAttribute('data-state', states[i]);
                
                const keyChar = guesses[currentRow][i];
                const keyEl = document.querySelector(`.key[data-key="${keyChar}"]`);
                if (keyEl) {
                    const oldState = keyEl.getAttribute('data-state');
                    if (states[i] === 'correct') {
                        keyEl.setAttribute('data-state', 'correct');
                    } else if (states[i] === 'present' && oldState !== 'correct') {
                        keyEl.setAttribute('data-state', 'present');
                    } else if (states[i] === 'absent' && oldState !== 'correct' && oldState !== 'present') {
                        keyEl.setAttribute('data-state', 'absent');
                    }
                }
            }, i * 250);
        });

        setTimeout(() => {
            if (roundId !== currentGameId) return;

            if (guessWord === currentTarget) {
                showMessage('ğŸ‰ æ­å–œä½ çŒœå¯¹äº†ï¼', 2000);
                isGameOver = true;
            } else {
                if (currentRow >= maxGuesses - 1) {
                    showMessage(`æ¸¸æˆç»“æŸï¼ç­”æ¡ˆæ˜¯: ${currentTarget.toUpperCase()}`, -1); 
                    isGameOver = true;
                } else {
                    currentRow++;
                    currentTile = 0;
                }
            }
        }, wordLength * 250);
    }

    function showMessage(text, duration = 1000) {
        const msgContainer = document.getElementById('message-container');
        const msg = document.createElement('div');
        msg.classList.add('message');
        msg.textContent = text;
        msgContainer.appendChild(msg);
        
        if (duration > 0) {
            setTimeout(() => {
                if (msg.parentNode === msgContainer) {
                    msg.style.opacity = 0;
                    setTimeout(() => {
                        if (msg.parentNode === msgContainer) msgContainer.removeChild(msg);
                    }, 500);
                }
            }, duration);
        }
    }

    function shakeRow() {
        const rowTiles = [];
        for (let i = 0; i < wordLength; i++) {
            const tile = document.getElementById(`tile-${currentRow}-${i}`);
            if(tile) {
                tile.style.animation = 'shake 0.5s';
                tile.addEventListener('animationend', () => tile.style.animation = '', {once: true});
            }
        }
    }

    loadWordsAndStart(); 
</script>
<style>
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        20% { transform: translateX(-5px); }
        40% { transform: translateX(5px); }
        60% { transform: translateX(-5px); }
        80% { transform: translateX(5px); }
    }
</style>
</body>
</html>
