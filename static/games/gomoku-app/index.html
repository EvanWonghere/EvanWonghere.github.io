<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gomoku AI</title>
    <style>
        :root {
            --bg-color: #f0f0f0;
            --board-bg: #eecfa1;
            --text-color: #333;
            --btn-bg: #fff;
            --btn-shadow: rgba(0,0,0,0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #1a1a1a;
                --board-bg: #cca46d; /* æ·±è‰²æ¨¡å¼ä¸‹æ£‹ç›˜ç¨å¾®æš—ä¸€ç‚¹ */
                --text-color: #e0e0e0;
                --btn-bg: #333;
                --btn-shadow: rgba(0,0,0,0.5);
            }
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
            overflow: hidden;
            touch-action: none; /* ç¦æ­¢ç§»åŠ¨ç«¯æ‹–åŠ¨é¡µé¢ */
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 95vw;
            max-width: 450px;
            margin-bottom: 10px;
        }

        h1 { font-size: 1.5rem; margin: 0; }

        .status {
            font-size: 1rem;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 15px;
            background: var(--btn-bg);
            box-shadow: 0 2px 5px var(--btn-shadow);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .status-dot {
            width: 12px; height: 12px; border-radius: 50%; display: inline-block;
        }
        .status.black .status-dot { background: #000; border: 1px solid #fff; }
        .status.white .status-dot { background: #fff; border: 1px solid #ccc; }

        /* æ£‹ç›˜å®¹å™¨ */
        .board-wrapper {
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-radius: 4px;
            background: var(--board-bg);
            /* æœ¨çº¹ç†æ•ˆæœ */
            background-image: linear-gradient(45deg, rgba(0,0,0,0.03) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.03) 75%, rgba(0,0,0,0.03)), 
                              linear-gradient(45deg, rgba(0,0,0,0.03) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.03) 75%, rgba(0,0,0,0.03));
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        canvas {
            display: block;
            cursor: pointer;
            border-radius: 4px;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            border: none;
            border-radius: 20px;
            background: var(--btn-bg);
            color: var(--text-color);
            box-shadow: 0 2px 5px var(--btn-shadow);
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        
        /* èƒœåˆ©/æ€è€ƒä¸­ æµ®å±‚ */
        .overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.2rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
        }
        .overlay.show { opacity: 1; }

    </style>
</head>
<body>

<div class="header">
    <h1>äº”å­æ£‹ AI</h1>
    <div class="status black" id="status">
        <span class="status-dot"></span>
        <span id="status-text">ç©å®¶å›åˆ</span>
    </div>
</div>

<div class="board-wrapper">
    <canvas id="board"></canvas>
    <div class="overlay" id="msg-overlay"></div>
</div>

<div class="controls">
    <button onclick="undo()">æ‚”æ£‹</button>
    <button onclick="restartGame()">é‡æ–°å¼€å§‹</button>
</div>

<script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const statusText = document.getElementById('status-text');
    const overlay = document.getElementById('msg-overlay');

    // æ¸¸æˆé…ç½®
    const GRID_SIZE = 15;
    let CELL_SIZE = 30; // ç»™ä¸ªé»˜è®¤å€¼é˜²æ­¢è®¡ç®—å‰æŠ¥é”™
    let PADDING = 30;
    
    // çŠ¶æ€
    let board = []; 
    let history = []; 
    let isPlayerTurn = true;
    let isGameOver = false;
    let lastMove = null; 

    // åˆå§‹åŒ– Canvas å°ºå¯¸
    function resize() {
        const maxWidth = Math.min(window.innerWidth * 0.95, 450);
        const size = Math.floor(maxWidth);
        
        // å¤„ç†é«˜æ¸…å± (Retina)
        const dpr = window.devicePixelRatio || 1;
        canvas.width = size * dpr;
        canvas.height = size * dpr;
        canvas.style.width = size + 'px';
        canvas.style.height = size + 'px';
        
        ctx.scale(dpr, dpr);
        
        CELL_SIZE = size / (GRID_SIZE + 1);
        PADDING = CELL_SIZE;
        
        drawBoard();
    }

    function initGame() {
        // åˆå§‹åŒ– 15x15 çš„äºŒç»´æ•°ç»„
        board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
        history = [];
        isPlayerTurn = true;
        isGameOver = false;
        lastMove = null;
        updateStatus("ç©å®¶å›åˆ (é»‘æ£‹)", true);
        overlay.classList.remove('show');
        
        // åªæœ‰å½“å°ºå¯¸è®¡ç®—è¿‡ï¼ˆPADDINGæœ‰æ„ä¹‰ï¼‰æ—¶æ‰ç»˜åˆ¶ï¼Œé¿å…åˆå§‹åŒ–çš„æ— æ•ˆç»˜åˆ¶
        if (PADDING) drawBoard();
    }

    // --- ç»˜åˆ¶ç³»ç»Ÿ ---
    function drawBoard() {
        // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¦‚æœ board è¿˜æ²¡åˆå§‹åŒ–ï¼Œç›´æ¥é€€å‡ºï¼Œé˜²æ­¢æŠ¥é”™
        if (!board || board.length === 0) return;

        // æ¸…ç©º
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. ç”»ç½‘æ ¼çº¿
        ctx.beginPath();
        ctx.strokeStyle = "#5e401a";
        ctx.lineWidth = 1;
        
        for (let i = 0; i < GRID_SIZE; i++) {
            const pos = PADDING + i * CELL_SIZE;
            // æ¨ªçº¿
            ctx.moveTo(PADDING, pos);
            ctx.lineTo(PADDING + (GRID_SIZE - 1) * CELL_SIZE, pos);
            // ç«–çº¿
            ctx.moveTo(pos, PADDING);
            ctx.lineTo(pos, PADDING + (GRID_SIZE - 1) * CELL_SIZE);
        }
        ctx.stroke();

        // 2. ç”»å¤©å…ƒå’Œæ˜Ÿä½
        const stars = [3, 7, 11];
        ctx.fillStyle = "#5e401a";
        for (let r of stars) {
            for (let c of stars) {
                ctx.beginPath();
                ctx.arc(PADDING + c * CELL_SIZE, PADDING + r * CELL_SIZE, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 3. ç”»æ£‹å­
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (board[r][c] !== 0) {
                    drawPiece(r, c, board[r][c]);
                }
            }
        }

        // 4. é«˜äº®æœ€åä¸€æ‰‹
        if (lastMove) {
            const cx = PADDING + lastMove.c * CELL_SIZE;
            const cy = PADDING + lastMove.r * CELL_SIZE;
            ctx.beginPath();
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            const len = CELL_SIZE * 0.2;
            ctx.moveTo(cx - len, cy); ctx.lineTo(cx + len, cy);
            ctx.moveTo(cx, cy - len); ctx.lineTo(cx, cy + len);
            ctx.stroke();
        }
    }

    function drawPiece(r, c, type) {
        const cx = PADDING + c * CELL_SIZE;
        const cy = PADDING + r * CELL_SIZE;
        const radius = CELL_SIZE * 0.4;

        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);

        const gradient = ctx.createRadialGradient(
            cx - radius/3, cy - radius/3, radius/10,
            cx, cy, radius
        );

        if (type === 1) { // é»‘æ£‹
            gradient.addColorStop(0, "#666");
            gradient.addColorStop(1, "#000");
        } else { // ç™½æ£‹
            gradient.addColorStop(0, "#fff");
            gradient.addColorStop(1, "#ddd");
        }

        ctx.fillStyle = gradient;
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.fill();
        
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }

    // --- äº¤äº’é€»è¾‘ ---
    canvas.addEventListener('click', (e) => {
        if (isGameOver || !isPlayerTurn) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const c = Math.round((x - PADDING) / CELL_SIZE);
        const r = Math.round((y - PADDING) / CELL_SIZE);

        // æ ¡éªŒæœ‰æ•ˆæ€§ (è¿™é‡Œ board å·²ç»åˆå§‹åŒ–ï¼Œä¸ä¼šæŠ¥é”™äº†)
        if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[r][c] === 0) {
            placePiece(r, c, 1);
        }
    });

    function placePiece(r, c, role) {
        board[r][c] = role;
        lastMove = {r, c};
        history.push({r, c, role});
        drawBoard();

        if (checkWin(r, c, role)) {
            isGameOver = true;
            showMsg(role === 1 ? "ä½ èµ¢äº†ï¼ğŸ‰" : "AI èµ¢äº†ï¼ğŸ¤–");
            return;
        }

        if (role === 1) {
            isPlayerTurn = false;
            updateStatus("AI æ€è€ƒä¸­...", false);
            setTimeout(aiMove, 100); 
        } else {
            isPlayerTurn = true;
            updateStatus("ç©å®¶å›åˆ (é»‘æ£‹)", true);
        }
    }

    function undo() {
        if (history.length === 0 || isGameOver) return;
        if (history.length >= 2) {
            const m1 = history.pop();
            board[m1.r][m1.c] = 0;
            const m2 = history.pop();
            board[m2.r][m2.c] = 0;
            
            lastMove = history.length > 0 ? {r: history[history.length-1].r, c: history[history.length-1].c} : null;
            isPlayerTurn = true;
            isGameOver = false;
            updateStatus("ç©å®¶å›åˆ (é»‘æ£‹)", true);
            drawBoard();
        }
    }

    function restartGame() {
        initGame();
        // é‡å¯æ—¶é‡æ–°ç»˜åˆ¶ä¸€ä¸‹ï¼Œç¡®ä¿æ¸…é™¤æ£‹ç›˜
        drawBoard();
    }

    function updateStatus(text, isBlack) {
        statusText.textContent = text;
        statusEl.className = isBlack ? 'status black' : 'status white';
    }

    function showMsg(text) {
        overlay.textContent = text;
        overlay.classList.add('show');
    }

    // --- AI æ ¸å¿ƒé€»è¾‘ ---
    function aiMove() {
        let maxScore = -Infinity;
        let bestPoint = null;
        
        if (history.length === 0) {
            bestPoint = {r: 7, c: 7};
        } else {
            for(let r=0; r<GRID_SIZE; r++) {
                for(let c=0; c<GRID_SIZE; c++) {
                    if(board[r][c] === 0) {
                        if(!hasNeighbor(r, c)) continue;
                        const scoreAttack = evaluatePoint(r, c, 2); 
                        const scoreDefense = evaluatePoint(r, c, 1); 
                        const totalScore = scoreAttack + scoreDefense;

                        if (totalScore > maxScore) {
                            maxScore = totalScore;
                            bestPoint = {r, c};
                        } else if (totalScore === maxScore) {
                            if(Math.random() > 0.5) bestPoint = {r, c};
                        }
                    }
                }
            }
        }

        if (bestPoint) {
            placePiece(bestPoint.r, bestPoint.c, 2);
        } else {
            showMsg("å¹³å±€ï¼");
        }
    }

    function hasNeighbor(r, c) {
        const dist = 2;
        for(let i = r-dist; i <= r+dist; i++) {
            for(let j = c-dist; j <= c+dist; j++) {
                if(i>=0 && i<GRID_SIZE && j>=0 && j<GRID_SIZE) {
                    if(board[i][j] !== 0) return true;
                }
            }
        }
        return false;
    }

    function evaluatePoint(r, c, role) {
        let score = 0;
        board[r][c] = role;
        
        score += getLineScore(r, c, 1, 0, role);
        score += getLineScore(r, c, 0, 1, role);
        score += getLineScore(r, c, 1, 1, role);
        score += getLineScore(r, c, 1, -1, role);

        board[r][c] = 0;
        return score;
    }

    function getLineScore(r, c, dr, dc, role) {
        let count = 1;
        let emptyHead = false;
        let emptyTail = false;

        let i = 1;
        while(true) {
            let nr = r + dr*i, nc = c + dc*i;
            if(nr<0 || nr>=GRID_SIZE || nc<0 || nc>=GRID_SIZE) break;
            if(board[nr][nc] === role) { count++; } 
            else if(board[nr][nc] === 0) { emptyHead = true; break; } 
            else { break; }
            i++;
        }

        i = 1;
        while(true) {
            let nr = r - dr*i, nc = c - dc*i;
            if(nr<0 || nr>=GRID_SIZE || nc<0 || nc>=GRID_SIZE) break;
            if(board[nr][nc] === role) { count++; } 
            else if(board[nr][nc] === 0) { emptyTail = true; break; } 
            else { break; }
            i++;
        }

        if (count >= 5) return 100000;
        if (count === 4) {
            if (emptyHead && emptyTail) return 10000;
            if (emptyHead || emptyTail) return 1000;
        }
        if (count === 3) {
            if (emptyHead && emptyTail) return 1000;
            if (emptyHead || emptyTail) return 100;
        }
        if (count === 2) {
            if (emptyHead && emptyTail) return 100;
            if (emptyHead || emptyTail) return 10;
        }
        return 0;
    }

    function checkWin(r, c, role) {
        const dirs = [[1,0], [0,1], [1,1], [1,-1]];
        for (let [dr, dc] of dirs) {
            let count = 1;
            let i = 1;
            while(true) {
                let nr = r + dr*i, nc = c + dc*i;
                if(nr<0 || nr>=GRID_SIZE || nc<0 || nc>=GRID_SIZE || board[nr][nc] !== role) break;
                count++; i++;
            }
            i = 1;
            while(true) {
                let nr = r - dr*i, nc = c - dc*i;
                if(nr<0 || nr>=GRID_SIZE || nc<0 || nc>=GRID_SIZE || board[nr][nc] !== role) break;
                count++; i++;
            }
            if (count >= 5) return true;
        }
        return false;
    }

    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šè°ƒæ•´æ‰§è¡Œé¡ºåº
    // 1. å…ˆåˆå§‹åŒ–æ¸¸æˆæ•°æ® (è®© board å˜æˆæ•°ç»„ï¼Œä¸å†æ˜¯ç©º)
    initGame();
    
    // 2. å†ç»‘å®š Resize äº‹ä»¶
    window.addEventListener('resize', resize);
    
    // 3. æœ€åè®¡ç®—å°ºå¯¸å¹¶ç»˜åˆ¶ (è¿™æ—¶å€™ board å·²ç»æœ‰æ•°æ®äº†ï¼ŒdrawBoard ä¸ä¼šæŠ¥é”™)
    resize();

</script>
</body>
</html>
