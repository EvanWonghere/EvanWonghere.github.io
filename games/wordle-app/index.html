<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Wordle</title>
    <style>
        :root {
            --correct: #6aaa64;
            --present: #c9b458;
            --absent: #787c7e;
            --default-border: #d3d6da;
            --filled-border: #878a8c;
            --bg: #ffffff;
            --text: #000000;
            --key-bg: #d3d6da;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #121213;
                --text: #ffffff;
                --default-border: #3a3a3c;
                --filled-border: #565758;
                --key-bg: #818384;
            }
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border-bottom: 1px solid var(--default-border);
            width: 100%;
            gap: 10px;
        }

        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; }

        select {
            padding: 5px;
            font-size: 1rem;
            border-radius: 5px;
        }

        button.restart-btn {
            padding: 5px 10px;
            cursor: pointer;
            background: var(--correct);
            color: white;
            border: none;
            border-radius: 4px;
        }

        #game-board {
            display: grid;
            grid-gap: 5px;
            padding: 10px;
            box-sizing: border-box;
            flex-grow: 1;
            align-content: center;
            max-height: 65vh;
        }

        .tile {
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 2px solid var(--default-border);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            user-select: none;
        }

        /* åŠ¨æ€è°ƒæ•´æ ¼å­å¤§å°ï¼Œé˜²æ­¢å¤ªå°æˆ–å¤ªå¤§ */
        @media (max-height: 600px) { .tile { font-size: 1.5rem; } }

        .tile[data-state='active'] { border-color: var(--filled-border); animation: pop 0.1s; }
        .tile[data-state='correct'] { background-color: var(--correct); border-color: var(--correct); color: white; }
        .tile[data-state='present'] { background-color: var(--present); border-color: var(--present); color: white; }
        .tile[data-state='absent'] { background-color: var(--absent); border-color: var(--absent); color: white; }
        
        /* ç¿»è½¬åŠ¨ç”» */
        .tile.flip { animation: flip 0.5s ease forwards; }

        @keyframes pop { 50% { transform: scale(1.1); } }
        @keyframes flip {
            0% { transform: rotateX(0); }
            50% { transform: rotateX(90deg); }
            100% { transform: rotateX(0); }
        }

        #keyboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding-bottom: 20px;
            width: 100%;
            max-width: 500px;
        }

        .keyboard-row { display: flex; gap: 6px; width: 95%; justify-content: center; }
        .key {
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            text-transform: uppercase;
            background-color: var(--key-bg);
            color: var(--text); /* é€‚é…æ·±è‰²æ¨¡å¼æ–‡å­— */
            height: 58px;
            flex: 1;
            font-size: 1.2rem;
            user-select: none;
        }
        .key[data-key='Enter'], .key[data-key='Backspace'] { flex: 1.5; font-size: 0.8rem; }
        .key[data-state='correct'] { background-color: var(--correct); color: white; }
        .key[data-state='present'] { background-color: var(--present); color: white; }
        .key[data-state='absent'] { background-color: var(--absent); color: white; }

        #message-container {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        .message {
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .loading { opacity: 0.5; pointer-events: none; }
    </style>
</head>
<body>

<header>
    <select id="length-selector">
        <option value="3">3 å­—æ¯</option>
        <option value="4">4 å­—æ¯</option>
        <option value="5" selected>5 å­—æ¯</option>
        <option value="6">6 å­—æ¯</option>
        <option value="7">7 å­—æ¯</option>
    </select>
    <h1>WORDLE</h1>
    <button class="restart-btn" onclick="initGame()">é‡ç½®</button>
</header>

<div id="message-container"></div>

<div id="game-board"></div>

<div id="keyboard">
    <div class="keyboard-row" id="row-1"></div>
    <div class="keyboard-row" id="row-2"></div>
    <div class="keyboard-row" id="row-3"></div>
</div>

<script>
    // --- é…ç½®åŒº ---
    const KEYS = [
        ['q','w','e','r','t','y','u','i','o','p'],
        ['a','s','d','f','g','h','j','k','l'],
        ['Enter','z','x','c','v','b','n','m','Backspace']
    ];
    
    // ç®€å•çš„å†…ç½®è¯åº“ï¼Œç¡®ä¿æ¸¸æˆç¦»çº¿ä¹Ÿèƒ½ç©ã€‚
    // å®é™…æ ¡éªŒä¼šä½¿ç”¨åœ¨çº¿ APIï¼Œè¿™é‡Œåªä½œä¸ºâ€œç­”æ¡ˆâ€åº“ã€‚
    const TARGET_WORDS = {
        3: ["cat", "dog", "sun", "run", "sky", "box", "fox", "joy", "top", "art"],
        4: ["book", "love", "hope", "code", "data", "moon", "star", "fish", "bird", "game"],
        5: ["apple", "world", "hello", "smile", "happy", "music", "ocean", "space", "dream", "light"],
        6: ["planet", "friend", "banana", "orange", "guitar", "summer", "winter", "doctor", "family", "nature"],
        7: ["freedom", "journey", "history", "mystery", "silence", "perfect", "awesome", "morning", "station", "welcome"]
    };

    let wordLength = 5;
    let maxGuesses = 6; // wordLength + 1
    let currentTarget = "";
    let currentRow = 0;
    let currentTile = 0;
    let isGameOver = false;
    let isLoading = false; // æ ¡éªŒ API æ—¶é˜²æ­¢è¾“å…¥
    let guesses = []; // å­˜å‚¨æ¯ä¸€è¡Œçš„å­—æ¯

    // --- åˆå§‹åŒ– ---
    const board = document.getElementById('game-board');
    const keyboardContainer = document.getElementById('keyboard');
    const lengthSelector = document.getElementById('length-selector');

    lengthSelector.addEventListener('change', (e) => {
        wordLength = parseInt(e.target.value);
        initGame();
    });

    // åˆ›å»ºé”®ç›˜
    function createKeyboard() {
        const rows = ['row-1', 'row-2', 'row-3'];
        rows.forEach((rowId, index) => {
            const rowEl = document.getElementById(rowId);
            rowEl.innerHTML = '';
            KEYS[index].forEach(key => {
                const button = document.createElement('div');
                button.textContent = key === 'Backspace' ? 'âŒ«' : key;
                button.classList.add('key');
                button.setAttribute('data-key', key);
                button.addEventListener('click', () => handleInput(key));
                rowEl.appendChild(button);
            });
        });
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    function initGame() {
        // 1. é‡ç½®å˜é‡
        maxGuesses = wordLength + 1;
        currentRow = 0;
        currentTile = 0;
        isGameOver = false;
        guesses = Array(maxGuesses).fill(null).map(() => Array(wordLength).fill(''));
        board.innerHTML = '';
        document.querySelectorAll('.key').forEach(k => k.removeAttribute('data-state'));
        
        // 2. éšæœºé€‰æ‹©ç­”æ¡ˆ
        const list = TARGET_WORDS[wordLength];
        currentTarget = list[Math.floor(Math.random() * list.length)].toLowerCase();
        console.log("Target (Debug):", currentTarget); // æ–¹ä¾¿è°ƒè¯•

        // 3. ç”Ÿæˆç½‘æ ¼
        board.style.gridTemplateColumns = `repeat(${wordLength}, 1fr)`;
        board.style.width = `${wordLength * 60}px`; // åŠ¨æ€å®½åº¦
        board.style.maxWidth = '95%';

        for (let i = 0; i < maxGuesses * wordLength; i++) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.id = `tile-${Math.floor(i / wordLength)}-${i % wordLength}`;
            board.appendChild(tile);
        }
    }

    // --- æ ¸å¿ƒé€»è¾‘ ---

    // å¤„ç†è¾“å…¥
    function handleInput(key) {
        if (isGameOver || isLoading) return;

        if (key === 'Backspace') {
            if (currentTile > 0) {
                currentTile--;
                const tile = document.getElementById(`tile-${currentRow}-${currentTile}`);
                tile.textContent = '';
                tile.removeAttribute('data-state');
                guesses[currentRow][currentTile] = '';
            }
        } else if (key === 'Enter') {
            if (currentTile === wordLength) {
                checkGuess();
            } else {
                showMessage('å•è¯é•¿åº¦ä¸å¤Ÿ');
            }
        } else {
            // è¾“å…¥å­—æ¯
            if (currentTile < wordLength && /^[a-z]$/i.test(key)) {
                const tile = document.getElementById(`tile-${currentRow}-${currentTile}`);
                tile.textContent = key;
                tile.setAttribute('data-state', 'active');
                guesses[currentRow][currentTile] = key.toLowerCase();
                currentTile++;
            }
        }
    }

    // ç‰©ç†é”®ç›˜ç›‘å¬
    document.addEventListener('keydown', (e) => {
        let key = e.key;
        if (key === 'Enter' || key === 'Backspace') {
            handleInput(key);
        } else if (/^[a-zA-Z]$/.test(key)) {
            handleInput(key.toLowerCase());
        }
    });

    // æ ¡éªŒçŒœæµ‹
    async function checkGuess() {
        const guessWord = guesses[currentRow].join('');
        
        // è§„åˆ™5ï¼šæ ¡éªŒæ˜¯å¦ä¸ºåˆæ³•å•è¯ (ä½¿ç”¨ Dictionary API)
        isLoading = true;
        document.body.classList.add('loading');
        
        const isValid = await validateWord(guessWord);
        
        document.body.classList.remove('loading');
        isLoading = false;

        if (!isValid) {
            showMessage('ä¸æ˜¯åˆæ³•çš„å•è¯');
            shakeRow();
            return;
        }

        // ç¿»è½¬åŠ¨ç”»ä¸é¢œè‰²åˆ¤å®š
        flipTiles(guessWord);
    }

    // è°ƒç”¨å…è´¹ API éªŒè¯å•è¯
    async function validateWord(word) {
        // å¦‚æœåˆšå¥½çŒœä¸­ç­”æ¡ˆï¼Œç›´æ¥è¿”å› trueï¼Œé¿å… API ç½‘ç»œé—®é¢˜
        if (word === currentTarget) return true; 

        try {
            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            return response.ok; // 200 OK è¡¨ç¤ºå•è¯å­˜åœ¨
        } catch (error) {
            console.error("API Error, falling back to simple validation", error);
            return true; // å¦‚æœ API æŒ‚äº†ï¼Œä¸ºäº†ä¸å¡ä½ç©å®¶ï¼Œé»˜è®¤é€šè¿‡
        }
    }

    function flipTiles(guessWord) {
        const rowTiles = [];
        for (let i = 0; i < wordLength; i++) {
            rowTiles.push(document.getElementById(`tile-${currentRow}-${i}`));
        }

        // é¢œè‰²é€»è¾‘ (è§„åˆ™4)
        const targetChars = currentTarget.split('');
        const guessChars = guessWord.split('');
        const states = Array(wordLength).fill('absent'); // é»˜è®¤ä¸ºç°

        // ç¬¬ä¸€è½®ï¼šæ‰¾ç»¿è‰² (å®Œå…¨åŒ¹é…)
        guessChars.forEach((char, i) => {
            if (char === targetChars[i]) {
                states[i] = 'correct';
                targetChars[i] = null; // æ ‡è®°å·²å¤„ç†
                guessChars[i] = null;
            }
        });

        // ç¬¬äºŒè½®ï¼šæ‰¾é»„è‰² (å­˜åœ¨ä½†ä½ç½®ä¸å¯¹)
        guessChars.forEach((char, i) => {
            if (char !== null && targetChars.includes(char)) {
                states[i] = 'present';
                // ç§»é™¤ targetChars ä¸­çš„è¯¥å­—æ¯ï¼Œé˜²æ­¢é‡å¤æ ‡è®°
                targetChars[targetChars.indexOf(char)] = null; 
            }
        });

        // æ‰§è¡ŒåŠ¨ç”»å’Œä¸Šè‰²
        rowTiles.forEach((tile, i) => {
            setTimeout(() => {
                tile.classList.add('flip');
                tile.setAttribute('data-state', states[i]);
                
                // æ›´æ–°é”®ç›˜é¢œè‰²
                const keyChar = guesses[currentRow][i];
                const keyEl = document.querySelector(`.key[data-key='${keyChar}']`);
                const oldState = keyEl.getAttribute('data-state');
                
                // é¢œè‰²ä¼˜å…ˆçº§ï¼šcorrect > present > absent
                if (states[i] === 'correct') {
                    keyEl.setAttribute('data-state', 'correct');
                } else if (states[i] === 'present' && oldState !== 'correct') {
                    keyEl.setAttribute('data-state', 'present');
                } else if (states[i] === 'absent' && oldState !== 'correct' && oldState !== 'present') {
                    keyEl.setAttribute('data-state', 'absent');
                }

            }, i * 250);
        });

        // åŠ¨ç”»ç»“æŸååˆ¤æ–­èƒœè´Ÿ
        setTimeout(() => {
            if (guessWord === currentTarget) {
                showMessage('ğŸ‰ æ­å–œä½ çŒœå¯¹äº†ï¼', 2000);
                isGameOver = true;
            } else {
                if (currentRow >= maxGuesses - 1) {
                    showMessage(`æ¸¸æˆç»“æŸï¼ç­”æ¡ˆæ˜¯: ${currentTarget.toUpperCase()}`, -1); // -1 è¡¨ç¤ºä¸è‡ªåŠ¨æ¶ˆå¤±
                    isGameOver = true;
                } else {
                    currentRow++;
                    currentTile = 0;
                }
            }
        }, wordLength * 250);
    }

    // è¾…åŠ©åŠŸèƒ½ï¼šæ˜¾ç¤ºæ¶ˆæ¯
    function showMessage(text, duration = 1000) {
        const msgContainer = document.getElementById('message-container');
        const msg = document.createElement('div');
        msg.classList.add('message');
        msg.textContent = text;
        msgContainer.appendChild(msg);
        
        if (duration > 0) {
            setTimeout(() => {
                msg.style.opacity = 0;
                setTimeout(() => msgContainer.removeChild(msg), 500);
            }, duration);
        }
    }

    // è¾…åŠ©åŠŸèƒ½ï¼šè¡ŒæŠ–åŠ¨ (é”™è¯¯è¾“å…¥æ—¶)
    function shakeRow() {
        const rowTiles = [];
        for (let i = 0; i < wordLength; i++) {
            const tile = document.getElementById(`tile-${currentRow}-${i}`);
            tile.style.animation = 'shake 0.5s';
            tile.addEventListener('animationend', () => tile.style.animation = '', {once: true});
        }
        // éœ€è¦åœ¨ CSS åŠ  shake åŠ¨ç”» keyframesï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ç›´æ¥ç”¨ active æ ·å¼æç¤º
    }

    // å¯åŠ¨
    createKeyboard();
    initGame();
</script>
<style>
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        20% { transform: translateX(-5px); }
        40% { transform: translateX(5px); }
        60% { transform: translateX(-5px); }
        80% { transform: translateX(5px); }
    }
</style>
</body>
</html>
