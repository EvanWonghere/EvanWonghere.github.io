<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minesweeper</title>
    <style>
        :root {
            --bg-color: #c0c0c0;
            --border-light: #ffffff;
            --border-dark: #808080;
            --face-bg: #c0c0c0;
            --text-color: #000;
            --num-1: #0000ff; --num-2: #008000; --num-3: #ff0000; --num-4: #000080;
            --num-5: #800000; --num-6: #008080; --num-7: #000000; --num-8: #808080;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #2c2c2e;
                --border-light: #48484a;
                --border-dark: #1c1c1e;
                --face-bg: #3a3a3c;
                --text-color: #e5e5e7;
                /* æ·±è‰²æ¨¡å¼ä¸‹æ•°å­—é¢œè‰²å¾®è°ƒäº®ä¸€ç‚¹ */
                --num-1: #66b2ff; --num-2: #90ee90; --num-3: #ff6666; --num-4: #aaaaff;
                --num-5: #ffb3b3; --num-6: #80e5e5; --num-7: #e0e0e0; --num-8: #a0a0a0;
            }
        }

        body {
            background-color: #1a1a1a; /* ç½‘é¡µèƒŒæ™¯æ·±è‰²ï¼Œçªå‡ºä¸­é—´çš„æ¸¸æˆæœº */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: "Courier New", Courier, monospace;
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden;
        }

        /* æ¸¸æˆä¸»å®¹å™¨ (ç»å…¸çš„ Windows 95 æµ®é›•é£æ ¼) */
        .game-window {
            background-color: var(--bg-color);
            border: 3px solid;
            border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
            padding: 6px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 95vw;
            max-height: 95vh;
        }

        /* å¤´éƒ¨ä¿¡æ¯æ  */
        .header {
            border: 3px solid;
            border-color: var(--border-dark) var(--border-light) var(--border-light) var(--border-dark);
            padding: 6px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-color);
        }

        /* LED æ•°å­—æ˜¾ç¤º */
        .counter {
            background: #000;
            color: #ff0000;
            font-size: 26px;
            font-weight: bold;
            padding: 2px 4px;
            border: 2px solid;
            border-color: var(--border-dark) var(--border-light) var(--border-light) var(--border-dark);
            width: 50px;
            text-align: right;
            line-height: 1;
        }

        /* ç¬‘è„¸é‡ç½®æŒ‰é’® */
        .face-btn {
            width: 36px;
            height: 36px;
            border: 2px solid;
            border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
            background-color: var(--face-bg);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .face-btn:active {
            border-color: var(--border-dark) var(--border-light) var(--border-light) var(--border-dark);
            transform: translateY(1px);
        }

        /* æ¸¸æˆæ£‹ç›˜åŒºåŸŸ */
        .board-container {
            border: 3px solid;
            border-color: var(--border-dark) var(--border-light) var(--border-light) var(--border-dark);
            overflow: auto; /* å¦‚æœæ ¼å­å¤ªå¤šå…è®¸æ»šåŠ¨ */
            position: relative;
        }

        #grid {
            display: grid;
            background-color: var(--border-dark); /* æ ¼å­ç¼éš™é¢œè‰² */
            gap: 1px; 
        }

        .cell {
            width: 24px;
            height: 24px;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
            cursor: default;
        }

        /* æœªæŒ–æ˜çŠ¶æ€ï¼šå‡¸èµ·æ•ˆæœ */
        .cell.closed {
            border: 2px solid;
            border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
            box-sizing: border-box;
        }
        .cell.closed:active {
            border: none; /* æŒ‰ä¸‹æ•ˆæœ */
            background-color: #b0b0b0;
        }

        /* å·²æŒ–æ˜çŠ¶æ€ï¼šå¹³å¦ */
        .cell.opened {
            border: none;
            background-color: var(--bg-color);
        }

        /* å„ç§æ ‡è®° */
        .cell.flagged { color: red; }
        .cell.mine { background-color: #ff4d4d; } /* è¸©é›·çº¢è‰²èƒŒæ™¯ */
        .cell.mine-revealed { background-color: var(--bg-color); } /* æ¸¸æˆç»“æŸæ˜¾ç¤ºçš„é›· */

        /* æ•°å­—é¢œè‰² */
        .val-1 { color: var(--num-1); }
        .val-2 { color: var(--num-2); }
        .val-3 { color: var(--num-3); }
        .val-4 { color: var(--num-4); }
        .val-5 { color: var(--num-5); }
        .val-6 { color: var(--num-6); }
        .val-7 { color: var(--num-7); }
        .val-8 { color: var(--num-8); }

        /* åº•éƒ¨æ§åˆ¶æ  (éš¾åº¦ + æ¨¡å¼åˆ‡æ¢) */
        .controls {
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        
        select {
            padding: 5px;
            font-family: inherit;
            border-radius: 0;
            border: 2px solid;
            border-color: var(--border-dark) var(--border-light) var(--border-light) var(--border-dark);
            background: var(--bg-color);
            color: var(--text-color);
        }

        /* ç§»åŠ¨ç«¯ä¸“ç”¨ï¼šæŒ–æ˜/æ’æ—— åˆ‡æ¢æŒ‰é’® */
        .mode-switch {
            flex: 1;
            height: 30px;
            border: 2px solid;
            border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
            background: var(--bg-color);
            color: var(--text-color);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        .mode-switch.flag-mode {
            background: #ddd;
            border-color: var(--border-dark) var(--border-light) var(--border-light) var(--border-dark);
            color: red;
        }
    </style>
</head>
<body>

<div class="game-window">
    <div class="header">
        <div class="counter" id="mine-count">000</div>
        <div class="face-btn" id="face-btn" onclick="initGame()">ğŸ˜Š</div>
        <div class="counter" id="timer">000</div>
    </div>

    <div class="board-container" oncontextmenu="return false;">
        <div id="grid"></div>
    </div>

    <div class="controls">
        <select id="difficulty" onchange="changeDifficulty()">
            <option value="easy">ç®€å• (9x9)</option>
            <option value="medium" selected>ä¸­ç­‰ (16x16)</option>
            <option value="hard">å›°éš¾ (30x16)</option>
        </select>
        <button class="mode-switch" id="mode-btn" onclick="toggleMode()">
            â›ï¸ æŒ–æ˜æ¨¡å¼
        </button>
    </div>
</div>

<script>
    // æ¸¸æˆé…ç½®
    const PRESETS = {
        easy: { rows: 9, cols: 9, mines: 10 },
        medium: { rows: 16, cols: 16, mines: 40 },
        hard: { rows: 16, cols: 30, mines: 99 } // æ‰‹æœºä¸Šå¯èƒ½éœ€è¦æ¨ªå±æˆ–æ»šåŠ¨
    };

    // çŠ¶æ€å˜é‡
    let config = PRESETS.medium;
    let board = []; // å­˜å‚¨æ¯ä¸ªæ ¼å­çš„æ•°æ® { isMine, isOpen, isFlag, value }
    let gameStarted = false;
    let gameOver = false;
    let minesLeft = 0;
    let timeElapsed = 0;
    let timerInterval;
    let isFlagMode = false; // false: æŒ–æ˜, true: æ’æ——

    // DOM å…ƒç´ 
    const gridEl = document.getElementById('grid');
    const mineCountEl = document.getElementById('mine-count');
    const timerEl = document.getElementById('timer');
    const faceBtn = document.getElementById('face-btn');
    const modeBtn = document.getElementById('mode-btn');

    // åˆå§‹åŒ–
    function initGame() {
        // åœæ­¢è®¡æ—¶å™¨
        clearInterval(timerInterval);
        timeElapsed = 0;
        gameStarted = false;
        gameOver = false;
        
        // é‡ç½® UI
        updateTimer();
        faceBtn.textContent = 'ğŸ˜Š';
        minesLeft = config.mines;
        updateMineCount();
        
        // ç”Ÿæˆç©ºç™½æ•°æ®
        board = [];
        for (let r = 0; r < config.rows; r++) {
            const row = [];
            for (let c = 0; c < config.cols; c++) {
                row.push({
                    r, c,
                    isMine: false,
                    isOpen: false,
                    isFlag: false,
                    value: 0 // å‘¨å›´é›·æ•°
                });
            }
            board.push(row);
        }

        renderGrid();
    }

    function changeDifficulty() {
        const diff = document.getElementById('difficulty').value;
        config = PRESETS[diff];
        initGame();
    }

    function renderGrid() {
        gridEl.innerHTML = '';
        gridEl.style.gridTemplateColumns = `repeat(${config.cols}, 24px)`;
        gridEl.style.gridTemplateRows = `repeat(${config.rows}, 24px)`;

        for (let r = 0; r < config.rows; r++) {
            for (let c = 0; c < config.cols; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell', 'closed');
                cell.id = `cell-${r}-${c}`;
                
                // é¼ æ ‡å·¦é”® / è§¦æ‘¸ç‚¹å‡»
                cell.onclick = () => handleClick(r, c);
                // é¼ æ ‡å³é”®æ’æ——
                cell.onmousedown = (e) => {
                    if (e.button === 2) handleFlag(r, c);
                };
                
                gridEl.appendChild(cell);
            }
        }
    }

    // æ ¸å¿ƒé€»è¾‘ï¼šæ”¾ç½®åœ°é›· (åˆè§é˜²æ€ï¼šæ’é™¤æ‰ç¬¬ä¸€æ¬¡ç‚¹å‡»çš„ä½ç½®åŠå…¶å‘¨å›´)
    function placeMines(excludeR, excludeC) {
        let minesPlaced = 0;
        while (minesPlaced < config.mines) {
            const r = Math.floor(Math.random() * config.rows);
            const c = Math.floor(Math.random() * config.cols);

            // æ’é™¤ç¬¬ä¸€æ¬¡ç‚¹å‡»çš„åŒºåŸŸ (3x3)
            if (Math.abs(r - excludeR) <= 1 && Math.abs(c - excludeC) <= 1) continue;

            if (!board[r][c].isMine) {
                board[r][c].isMine = true;
                minesPlaced++;
            }
        }

        // è®¡ç®—æ•°å­—
        for (let r = 0; r < config.rows; r++) {
            for (let c = 0; c < config.cols; c++) {
                if (!board[r][c].isMine) {
                    board[r][c].value = countNeighbors(r, c);
                }
            }
        }
    }

    function countNeighbors(r, c) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const nr = r + i, nc = c + j;
                if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols) {
                    if (board[nr][nc].isMine) count++;
                }
            }
        }
        return count;
    }

    // å¤„ç†ç‚¹å‡»
    function handleClick(r, c) {
        if (gameOver) return;

        // æ’æ——æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»ç­‰åŒäºæ’æ——
        if (isFlagMode) {
            handleFlag(r, c);
            return;
        }

        const cellData = board[r][c];
        
        // å·²æ’æ——ä¸èƒ½ç‚¹
        if (cellData.isFlag) return;

        // å·²æ‰“å¼€çš„æ ¼å­ï¼šæ”¯æŒåŒå‡»å¿«é€Ÿå¼€å›¾ (Chording)
        if (cellData.isOpen) {
            handleChord(r, c);
            return;
        }

        // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Ÿç”Ÿæˆåœ°é›·å¹¶å¼€å§‹è®¡æ—¶
        if (!gameStarted) {
            gameStarted = true;
            placeMines(r, c);
            timerInterval = setInterval(() => {
                timeElapsed++;
                updateTimer();
            }, 1000);
        }

        openCell(r, c);
    }

    function handleFlag(r, c) {
        if (gameOver || !gameStarted && !isFlagMode) return; // æ²¡å¼€å§‹å‰ä¸èƒ½æ’æ——
        if (!gameStarted) {
            // å¦‚æœè¿˜æ²¡å¼€å§‹å°±æ’æ——ï¼Œä¹Ÿç®—å¼€å§‹æ¸¸æˆï¼ˆä¸ç”Ÿæˆé›·ï¼Œä½†å¼€å§‹UIçŠ¶æ€ï¼‰
             // å®é™…ä¸Šæ‰«é›·é€šå¸¸è¦æ±‚ç¬¬ä¸€ä¸‹å¿…é¡»æ˜¯æŒ–ï¼Œæ‰€ä»¥è¿™é‡Œå¦‚æœä¸å…è®¸æ’æ——ä½“éªŒæ›´å¥½
             return; 
        }

        const cellData = board[r][c];
        if (cellData.isOpen) return;

        cellData.isFlag = !cellData.isFlag;
        minesLeft += cellData.isFlag ? -1 : 1;
        updateMineCount();
        
        const el = document.getElementById(`cell-${r}-${c}`);
        if (cellData.isFlag) {
            el.classList.add('flagged');
            el.textContent = 'ğŸš©';
        } else {
            el.classList.remove('flagged');
            el.textContent = '';
        }
    }

    // æ‰“å¼€æ ¼å­
    function openCell(r, c) {
        const cellData = board[r][c];
        if (cellData.isOpen || cellData.isFlag) return;

        cellData.isOpen = true;
        const el = document.getElementById(`cell-${r}-${c}`);
        el.classList.remove('closed');
        el.classList.add('opened');

        if (cellData.isMine) {
            // è¸©é›·ï¼
            el.classList.add('mine');
            el.textContent = 'ğŸ’£';
            endGame(false);
        } else {
            // å®‰å…¨
            if (cellData.value > 0) {
                el.textContent = cellData.value;
                el.classList.add(`val-${cellData.value}`);
            } else {
                // ç©ºç™½æ ¼ï¼Œé€’å½’æ‰“å¼€å‘¨å›´
                el.textContent = '';
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const nr = r + i, nc = c + j;
                        if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols) {
                            openCell(nr, nc);
                        }
                    }
                }
            }
            checkWin();
        }
    }

    // åŒå‡»å¼€å›¾é€»è¾‘ (Chording)
    function handleChord(r, c) {
        const cellData = board[r][c];
        if (cellData.value === 0) return; // ç©ºç™½æ ¼æ²¡æœ‰é‚»å±…é›·

        // è®¡ç®—å‘¨å›´æ——å­æ•°é‡
        let flagCount = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const nr = r + i, nc = c + j;
                if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols) {
                    if (board[nr][nc].isFlag) flagCount++;
                }
            }
        }

        // å¦‚æœæ——å­æ•°é‡ç­‰äºæ•°å­—ï¼Œè‡ªåŠ¨æ‰“å¼€å‘¨å›´æœªæ’æ——çš„æ ¼å­
        if (flagCount === cellData.value) {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const nr = r + i, nc = c + j;
                    if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols) {
                        if (!board[nr][nc].isOpen && !board[nr][nc].isFlag) {
                            openCell(nr, nc);
                        }
                    }
                }
            }
        }
    }

    function checkWin() {
        let openedCount = 0;
        for (let r = 0; r < config.rows; r++) {
            for (let c = 0; c < config.cols; c++) {
                if (board[r][c].isOpen) openedCount++;
            }
        }
        
        if (openedCount === (config.rows * config.cols - config.mines)) {
            endGame(true);
        }
    }

    function endGame(win) {
        gameOver = true;
        clearInterval(timerInterval);
        faceBtn.textContent = win ? 'ğŸ˜' : 'ğŸ˜µ';
        
        if (!win) {
            // å¤±è´¥ï¼šæ˜¾ç¤ºæ‰€æœ‰åœ°é›·
            for (let r = 0; r < config.rows; r++) {
                for (let c = 0; c < config.cols; c++) {
                    if (board[r][c].isMine && !board[r][c].isFlag) {
                        const el = document.getElementById(`cell-${r}-${c}`);
                        el.classList.remove('closed');
                        el.classList.add('mine-revealed');
                        el.textContent = 'ğŸ’£';
                    }
                    // æ ‡é”™çš„é›·
                    if (!board[r][c].isMine && board[r][c].isFlag) {
                        const el = document.getElementById(`cell-${r}-${c}`);
                        el.textContent = 'âŒ';
                    }
                }
            }
        } else {
            // èƒœåˆ©ï¼šæ’æ»¡æ‰€æœ‰æ——å­
            minesLeft = 0;
            updateMineCount();
        }
    }

    function updateTimer() {
        timerEl.textContent = timeElapsed.toString().padStart(3, '0');
    }

    function updateMineCount() {
        mineCountEl.textContent = minesLeft.toString().padStart(3, '0');
    }

    // åˆ‡æ¢æ“ä½œæ¨¡å¼ (æ‰‹æœºç«¯ç”¨)
    function toggleMode() {
        isFlagMode = !isFlagMode;
        if (isFlagMode) {
            modeBtn.classList.add('flag-mode');
            modeBtn.textContent = 'ğŸš© æ’æ——æ¨¡å¼';
        } else {
            modeBtn.classList.remove('flag-mode');
            modeBtn.textContent = 'â›ï¸ æŒ–æ˜æ¨¡å¼';
        }
    }

    // å¯åŠ¨
    initGame();

</script>
</body>
</html>
