<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Logic</title>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --grid-color: #333;
            --cell-bg: #fff;
            --filled-color: #2c3e50;
            --cross-color: #e74c3c;
            --hint-bg: #e0e0e0;
            --hint-text: #555;
            --highlight: #a29bfe;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #1e1e1e;
                --grid-color: #888;
                --cell-bg: #2d2d2d;
                --filled-color: #a29bfe; /* äº®ç´«è‰² */
                --cross-color: #ff7675;
                --hint-bg: #333;
                --hint-text: #ccc;
            }
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
            touch-action: manipulation;
        }

        h1 { margin: 0 0 10px; color: var(--filled-color); font-size: 1.5rem; }

        .controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
        }

        select, button {
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid var(--grid-color);
            background: var(--cell-bg);
            color: var(--filled-color);
            font-size: 1rem;
            cursor: pointer;
        }

        /* æ¸¸æˆåŒºåŸŸå®¹å™¨ */
        .game-container {
            display: grid;
            /* åŠ¨æ€å®šä¹‰ grid-template-columns/rows */
            gap: 1px;
            background: var(--grid-color);
            border: 2px solid var(--grid-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .cell {
            background: var(--cell-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            position: relative;
        }

        /* æç¤ºåŒº */
        .hint-row, .hint-col {
            background: var(--hint-bg);
            color: var(--hint-text);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            line-height: 1.2;
        }
        .hint-row { flex-direction: row; gap: 5px; padding: 0 5px; justify-content: flex-end; }
        .hint-col { flex-direction: column; gap: 2px; padding: 5px 0; justify-content: flex-end; }
        .hint-done { color: #aaa; text-decoration: line-through; }

        /* æ ¼å­çŠ¶æ€ */
        .filled { background-color: var(--filled-color) !important; }
        .crossed::after { content: "Ã—"; color: var(--cross-color); font-size: 20px; }
        .cell:hover { filter: brightness(0.9); }

        /* ç²—çº¿åˆ†å‰² (5x5) */
        .border-right { border-right: 2px solid var(--grid-color); }
        .border-bottom { border-bottom: 2px solid var(--grid-color); }

        /* ç§»åŠ¨ç«¯åˆ‡æ¢æŒ‰é’® */
        .mode-switch {
            margin-top: 20px;
            display: flex;
            gap: 0;
            border: 1px solid var(--filled-color);
            border-radius: 20px;
            overflow: hidden;
        }
        .mode-btn {
            padding: 10px 30px;
            border: none;
            background: transparent;
            color: var(--filled-color);
            border-radius: 0;
            font-weight: bold;
        }
        .mode-btn.active {
            background: var(--filled-color);
            color: #fff;
        }

        /* èƒœåˆ©å¼¹çª— */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #overlay.show { display: flex; }
        .win-msg { font-size: 2rem; margin-bottom: 20px; color: #00ff88; }

    </style>
</head>
<body>

<h1>Pixel Logic</h1>

<div class="controls">
    <select id="level-select" onchange="changeLevel()">
        <option value="heart">â¤ï¸ Heart (5x5)</option>
        <option value="smile">ğŸ˜Š Smile (5x5)</option>
        <option value="duck">ğŸ¦† Duck (10x10)</option>
        <option value="invader">ğŸ‘¾ Invader (10x10)</option>
        <option value="coffee">â˜• Coffee (10x10)</option>
        <option value="house">ğŸ  House (15x15)</option>
    </select>
    <button onclick="resetGame()">Reset</button>
</div>

<div id="game-wrapper"></div>

<div class="mode-switch">
    <button class="mode-btn active" id="mode-fill" onclick="setMode('fill')">â¬› å¡«è‰²</button>
    <button class="mode-btn" id="mode-cross" onclick="setMode('cross')">âŒ æ ‡è®°</button>
</div>

<div id="overlay">
    <div class="win-msg">Puzzle Solved!</div>
    <button onclick="nextLevel()" style="font-size: 1.2rem; padding: 10px 30px;">Next Level</button>
</div>

<script>
    // --- å…³å¡æ•°æ® (0:ç©º, 1:å¡«) ---
    const LEVELS = {
        heart: [
            [0,1,0,1,0],
            [1,1,1,1,1],
            [1,1,1,1,1],
            [0,1,1,1,0],
            [0,0,1,0,0]
        ],
        smile: [
            [0,1,1,1,0],
            [1,0,1,0,1],
            [1,0,0,0,1],
            [1,1,0,1,1],
            [0,1,1,1,0]
        ],
        duck: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,1,1,0,0,0,0,0],
            [0,0,1,1,1,0,0,0,0,0],
            [0,0,0,1,1,0,0,0,0,0],
            [0,0,1,1,1,1,1,0,0,0],
            [0,1,1,1,1,1,1,1,0,0],
            [1,1,1,1,1,1,1,1,1,0],
            [0,0,1,1,1,1,1,0,0,0],
            [0,0,1,1,0,1,1,0,0,0],
            [0,0,0,0,0,0,0,0,0,0]
        ],
        invader: [
            [0,0,1,0,0,0,0,0,1,0],
            [0,0,0,1,0,0,0,1,0,0],
            [0,0,1,1,1,1,1,1,1,0],
            [0,1,1,0,1,1,1,0,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,0,1,1,1,1,1,1,1,1],
            [1,0,1,0,0,0,0,0,1,0],
            [0,0,0,1,1,0,1,1,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0]
        ],
        coffee: [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,1,0,1,0,0,0,0,0],
            [0,0,1,0,1,0,0,0,0,0],
            [0,1,1,1,1,1,1,0,0,0],
            [0,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,0,1,0],
            [0,0,1,1,1,1,0,0,1,0],
            [0,0,0,1,1,0,0,0,0,0],
            [0,0,1,1,1,1,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0]
        ],
        house: [
            [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,1,1,1,1,1,0,0,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,1,0,0,0,1,1,1,0,0,0,1,0],
            [0,1,1,0,1,0,1,1,1,0,1,0,1,0],
            [0,1,1,0,1,0,1,1,1,0,1,0,1,0],
            [0,1,1,0,0,0,1,1,1,0,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,0]
        ]
    };

    let currentGrid = []; // ç”¨æˆ·å½“å‰çŠ¶æ€ 0:ç©º, 1:å¡«, 2:X
    let solutionGrid = [];
    let size = 5;
    let isDragging = false;
    let dragMode = 1; // 1: fill, 2: cross, 0: erase
    let currentTool = 'fill'; // UIé€‰æ‹©çš„å·¥å…·

    function changeLevel() {
        const key = document.getElementById('level-select').value;
        loadLevel(LEVELS[key]);
    }

    function loadLevel(data) {
        solutionGrid = data;
        size = data.length;
        currentGrid = Array(size).fill(null).map(() => Array(size).fill(0));
        
        document.getElementById('overlay').classList.remove('show');
        renderGame();
    }

    // è®¡ç®—æç¤ºæ•°å­—
    function getHints(arr) {
        let hints = [];
        let count = 0;
        for (let val of arr) {
            if (val === 1) count++;
            else if (count > 0) { hints.push(count); count = 0; }
        }
        if (count > 0) hints.push(count);
        if (hints.length === 0) hints.push(0);
        return hints;
    }

    function renderGame() {
        const container = document.getElementById('game-wrapper');
        container.innerHTML = '';
        
        // åŠ¨æ€è®¡ç®— Grid å¸ƒå±€ï¼š (1 + size) x (1 + size)
        // ç¬¬ä¸€è¡Œæ˜¯åˆ—æç¤ºï¼Œç¬¬ä¸€åˆ—æ˜¯è¡Œæç¤º
        const wrapper = document.createElement('div');
        wrapper.className = 'game-container';
        wrapper.style.gridTemplateColumns = `50px repeat(${size}, 25px)`; // æç¤ºåˆ—å®½50ï¼Œæ ¼å­å®½25
        wrapper.style.gridTemplateRows = `50px repeat(${size}, 25px)`;

        // 1. å·¦ä¸Šè§’ç©ºç™½
        wrapper.appendChild(createDiv('cell'));

        // 2. é¡¶éƒ¨åˆ—æç¤º
        for (let c = 0; c < size; c++) {
            const colData = solutionGrid.map(row => row[c]);
            const hints = getHints(colData);
            const div = createDiv('hint-col');
            div.innerHTML = hints.join('<br>'); // ç«–å‘æ’åˆ—
            div.id = `hint-col-${c}`;
            if((c+1)%5===0 && c!==size-1) div.classList.add('border-right'); // 5æ ¼åˆ†å‰²çº¿
            wrapper.appendChild(div);
        }

        // 3. æ¯ä¸€è¡Œï¼šå·¦ä¾§æç¤º + æ ¼å­
        for (let r = 0; r < size; r++) {
            // å·¦ä¾§è¡Œæç¤º
            const hints = getHints(solutionGrid[r]);
            const hintDiv = createDiv('hint-row');
            hintDiv.innerText = hints.join(' ');
            hintDiv.id = `hint-row-${r}`;
            if((r+1)%5===0 && r!==size-1) hintDiv.classList.add('border-bottom');
            wrapper.appendChild(hintDiv);

            // æ ¼å­
            for (let c = 0; c < size; c++) {
                const cell = createDiv('cell');
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.id = `cell-${r}-${c}`;
                
                // äº¤äº’äº‹ä»¶
                cell.addEventListener('mousedown', onMouseDown);
                cell.addEventListener('mouseenter', onMouseEnter);
                // ç¦æ­¢å³é”®èœå•
                cell.addEventListener('contextmenu', e => e.preventDefault());
                
                if((c+1)%5===0 && c!==size-1) cell.classList.add('border-right');
                if((r+1)%5===0 && r!==size-1) cell.classList.add('border-bottom');
                
                wrapper.appendChild(cell);
            }
        }

        container.appendChild(wrapper);
    }

    function createDiv(cls) {
        const d = document.createElement('div');
        d.className = cls;
        return d;
    }

    // --- äº¤äº’é€»è¾‘ ---
    function onMouseDown(e) {
        e.preventDefault();
        const r = parseInt(this.dataset.r);
        const c = parseInt(this.dataset.c);
        
        // ç¡®å®šæ¨¡å¼ï¼šå·¦é”®ç”¨ currentToolï¼Œå³é”®å¼ºåˆ¶ Cross
        let tool = currentTool;
        if (e.button === 2) tool = 'cross';

        const currentVal = currentGrid[r][c];
        // å¦‚æœå½“å‰æ ¼å·²ç»ç¬¦åˆå·¥å…·ï¼Œåˆ™å˜æˆæ©¡çš®æ“¦
        if (tool === 'fill') dragMode = (currentVal === 1) ? 0 : 1;
        else dragMode = (currentVal === 2) ? 0 : 2;

        isDragging = true;
        updateCell(r, c);
        
        window.addEventListener('mouseup', onMouseUp);
    }

    function onMouseEnter(e) {
        if (!isDragging) return;
        const r = parseInt(this.dataset.r);
        const c = parseInt(this.dataset.c);
        updateCell(r, c);
    }

    function onMouseUp() {
        isDragging = false;
        window.removeEventListener('mouseup', onMouseUp);
        checkWin();
    }

    function updateCell(r, c) {
        if (currentGrid[r][c] === dragMode) return;
        
        // ä¿æŠ¤é€»è¾‘ï¼šå¦‚æœæˆ‘æƒ³å¡«è‰²ï¼Œä½†æ ¼å­å·²ç»æ˜¯Xï¼Œé€šå¸¸ä¸è¦†ç›–ï¼Œé™¤éå…ˆæ“¦é™¤
        // è¿™é‡Œç®€åŒ–é€»è¾‘ï¼šç›´æ¥è¦†ç›–
        currentGrid[r][c] = dragMode;
        
        const cell = document.getElementById(`cell-${r}-${c}`);
        cell.className = 'cell'; // é‡ç½®åŸºç¡€ç±»
        if((c+1)%5===0 && c!==size-1) cell.classList.add('border-right'); // è¡¥å›è¾¹æ¡†
        if((r+1)%5===0 && r!==size-1) cell.classList.add('border-bottom');

        if (dragMode === 1) cell.classList.add('filled');
        if (dragMode === 2) cell.classList.add('crossed');
        
        checkHints(r, c);
    }

    // æ£€æŸ¥æç¤ºæ˜¯å¦å®Œæˆï¼ˆå˜ç°ï¼‰
    function checkHints(r, c) {
        // æ£€æŸ¥è¡Œ
        const rowState = currentGrid[r].map(v => v === 1 ? 1 : 0);
        const rowSol = solutionGrid[r];
        const rowHint = document.getElementById(`hint-row-${r}`);
        if (JSON.stringify(rowState) === JSON.stringify(rowSol)) rowHint.classList.add('hint-done');
        else rowHint.classList.remove('hint-done');

        // æ£€æŸ¥åˆ—
        const colState = currentGrid.map(row => row[c] === 1 ? 1 : 0);
        const colSol = solutionGrid.map(row => row[c]);
        const colHint = document.getElementById(`hint-col-${c}`);
        if (JSON.stringify(colState) === JSON.stringify(colSol)) colHint.classList.add('hint-done');
        else colHint.classList.remove('hint-done');
    }

    function checkWin() {
        // åªæ¯”å¯¹å¡«è‰²æ ¼å­ (1)ï¼ŒX (2) å’Œ ç©º (0) éƒ½è§†ä¸ºéå¡«è‰²
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                const userFill = currentGrid[r][c] === 1 ? 1 : 0;
                if (userFill !== solutionGrid[r][c]) return;
            }
        }
        
        // èƒœåˆ©
        document.getElementById('overlay').classList.add('show');
    }

    function setMode(mode) {
        currentTool = mode;
        document.getElementById('mode-fill').classList.toggle('active', mode==='fill');
        document.getElementById('mode-cross').classList.toggle('active', mode==='cross');
    }

    function resetGame() {
        const key = document.getElementById('level-select').value;
        loadLevel(LEVELS[key]);
    }
    
    function nextLevel() {
        const select = document.getElementById('level-select');
        if (select.selectedIndex < select.options.length - 1) {
            select.selectedIndex++;
            changeLevel();
        } else {
            alert("å…¨å…³å¡é€šå…³ï¼æ­å–œï¼");
            document.getElementById('overlay').classList.remove('show');
        }
    }

    // å¯åŠ¨
    changeLevel();

</script>
</body>
</html>
