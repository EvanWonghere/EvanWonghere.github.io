<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Game of Life</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --grid-line: #1f242c;
            --cell-color: #39d353; /* GitHub Green style */
            --cell-shadow: #39d353;
            --panel-bg: rgba(13, 17, 23, 0.85);
            --text-color: #c9d1d9;
            --btn-border: #30363d;
            --btn-hover: #21262d;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            touch-action: none;
        }

        /* æ¸¸æˆç”»å¸ƒ */
        canvas {
            display: block;
            cursor: crosshair;
        }

        /* æ‚¬æµ®æ§åˆ¶é¢æ¿ */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--btn-border);
            border-radius: 12px;
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 10;
            width: 90%;
            max-width: 600px;
        }

        /* é¡¶éƒ¨æ ‡é¢˜/çŠ¶æ€ */
        .status-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            font-family: monospace;
            font-size: 14px;
            opacity: 0.7;
            text-shadow: 0 1px 2px black;
        }
        h1 {
            margin: 0 0 5px 0;
            font-size: 20px;
            font-weight: bold;
            color: var(--cell-color);
        }

        /* æŒ‰é’®æ ·å¼ */
        button {
            background: transparent;
            border: 1px solid var(--btn-border);
            color: var(--text-color);
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        button:hover { background: var(--btn-hover); border-color: #8b949e; }
        button:active { transform: scale(0.95); }
        button.primary { background: #238636; border-color: #238636; color: white; }
        button.primary:hover { background: #2ea043; }

        /* æ»‘å—æ ·å¼ */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        input[type=range] {
            width: 80px;
            accent-color: var(--cell-color);
        }

        /* é¢„è®¾èœå• */
        .presets {
            display: flex;
            gap: 5px;
            padding-left: 10px;
            border-left: 1px solid var(--btn-border);
        }
        
        @media (max-width: 600px) {
            .controls { padding: 10px; bottom: 10px; }
            .presets { display: none; /* æ‰‹æœºä¸Šéšè—é¢„è®¾ï¼ŒèŠ‚çœç©ºé—´ */ }
            .slider-group { display: none; }
        }
        
        /* ç§»åŠ¨ç«¯ä¸“ç”¨èœå•æŒ‰é’® */
        .mobile-menu-btn {
            display: none;
        }
        @media (max-width: 600px) {
            .mobile-menu-btn { display: block; }
        }
        
        /* ç§»åŠ¨ç«¯é¢„è®¾å¼¹çª— */
        #mobile-presets {
            display: none;
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--btn-border);
            padding: 10px;
            border-radius: 8px;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
        }
        #mobile-presets.show { display: flex; }

    </style>
</head>
<body>

<div class="status-bar">
    <h1>LIFE_OS v1.0</h1>
    <div>GEN: <span id="gen-count">0</span></div>
    <div>POP: <span id="pop-count">0</span></div>
</div>

<canvas id="gridCanvas"></canvas>

<div id="mobile-presets">
    <button onclick="loadPreset('glider')">æ»‘ç¿”æœº</button>
    <button onclick="loadPreset('pulsar')">è„‰å†²æ˜Ÿ</button>
    <button onclick="loadPreset('gun')">æ»‘ç¿”æœºæª</button>
    <button onclick="randomize()">éšæœº</button>
</div>

<div class="controls">
    <button id="play-btn" class="primary" onclick="togglePlay()">â–¶ è¿è¡Œ</button>
    <button onclick="step()">ğŸ‘£ å•æ­¥</button>
    <button onclick="clearGrid()">ğŸ—‘ï¸ æ¸…ç©º</button>
    
    <div class="slider-group">
        <span>é€Ÿåº¦</span>
        <input type="range" min="1" max="60" value="30" id="speed-range" oninput="updateSpeed(this.value)">
    </div>

    <div class="presets">
        <button onclick="loadPreset('glider')">æ»‘ç¿”æœº</button>
        <button onclick="loadPreset('pulsar')">è„‰å†²æ˜Ÿ</button>
        <button onclick="loadPreset('gun')">æ»‘ç¿”æœºæª</button>
        <button onclick="randomize()">éšæœºåŒ–</button>
    </div>

    <button class="mobile-menu-btn" onclick="toggleMobilePresets()">ğŸ“‚ é¢„è®¾</button>
</div>

<script>
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const genCountEl = document.getElementById('gen-count');
    const popCountEl = document.getElementById('pop-count');
    const playBtn = document.getElementById('play-btn');
    const mobilePresets = document.getElementById('mobile-presets');

    // é…ç½®
    const CELL_SIZE = 10; // æ ¼å­å¤§å° (åƒç´ )
    let COLS, ROWS;
    let grid = [];
    let nextGrid = [];
    
    let isPlaying = false;
    let generation = 0;
    let population = 0;
    let animationId;
    let lastFrameTime = 0;
    let fps = 30;
    let frameInterval = 1000 / fps;

    // --- åˆå§‹åŒ– ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        COLS = Math.ceil(canvas.width / CELL_SIZE);
        ROWS = Math.ceil(canvas.height / CELL_SIZE);
        
        // é‡ç½®ç½‘æ ¼æ—¶å°½é‡ä¿ç•™åŸå†…å®¹ (å¦‚æœæ˜¯æ‰©å®¹)
        // ä¸ºç®€å•èµ·è§ï¼Œè¿™é‡Œç›´æ¥é‡ç½®
        initGrids();
        draw();
    }

    function initGrids() {
        grid = createEmptyGrid();
        nextGrid = createEmptyGrid();
        generation = 0;
        population = 0;
        updateUI();
        
        // åˆå§‹åŠ è½½ä¸€ä¸ªéšæœºå›¾
        randomize();
    }

    function createEmptyGrid() {
        return new Array(COLS).fill(null).map(() => new Array(ROWS).fill(0));
    }

    window.addEventListener('resize', resize);

    // --- æ ¸å¿ƒé€»è¾‘ ---
    function update() {
        population = 0;
        let activity = false; // æ£€æµ‹æ˜¯å¦æœ‰å˜åŒ–

        // äº¤æ¢æ•°ç»„ (ping-pong buffer)
        // ä¸ºäº†ä¸é‡æ–°åˆ†é…å†…å­˜ï¼Œæˆ‘ä»¬ç›´æ¥å¤ç”¨ nextGridï¼Œä½†éœ€è¦æ¸…é›¶å—ï¼Ÿ
        // å…¶å®ç›´æ¥è®¡ç®—è¦†ç›–å³å¯ã€‚
        
        // åº·å¨è§„åˆ™ï¼š
        // 1. < 2 æ´»é‚»å±… -> æ­» (å­¤ç‹¬)
        // 2. 2 æˆ– 3 æ´»é‚»å±… -> æ´» (å­˜æ´»)
        // 3. > 3 æ´»é‚»å±… -> æ­» (æ‹¥æŒ¤)
        // 4. 3 æ´»é‚»å±… -> ç”Ÿ (ç¹æ®–)
        
        for (let col = 0; col < COLS; col++) {
            for (let row = 0; row < ROWS; row++) {
                const cell = grid[col][row];
                let numNeighbors = countNeighbors(grid, col, row);
                
                let nextState = 0;
                if (cell === 1 && (numNeighbors < 2 || numNeighbors > 3)) {
                    nextState = 0;
                } else if (cell === 0 && numNeighbors === 3) {
                    nextState = 1;
                } else {
                    nextState = cell;
                }

                nextGrid[col][row] = nextState;
                
                if (nextState === 1) population++;
                if (nextState !== cell) activity = true;
            }
        }

        // å°† nextGrid æ‹·è´å› grid (æˆ–è€…äº¤æ¢å¼•ç”¨)
        // äº¤æ¢å¼•ç”¨æ›´é«˜æ•ˆ
        let temp = grid;
        grid = nextGrid;
        nextGrid = temp; // nextGrid å˜æˆäº†æ—§çš„ gridï¼Œä¸‹ä¸€æ¬¡å¾ªç¯ä¼šè¢«è¦†ç›–

        if (activity) generation++;
        updateUI();
    }

    function countNeighbors(grid, x, y) {
        let sum = 0;
        for (let i = -1; i < 2; i++) {
            for (let j = -1; j < 2; j++) {
                // ç¯é¢æ‹“æ‰‘ (Toroidal array): èµ°å‡ºè¾¹ç•Œä¼šä»å¦ä¸€è¾¹å›æ¥
                let col = (x + i + COLS) % COLS;
                let row = (y + j + ROWS) % ROWS;
                sum += grid[col][row];
            }
        }
        sum -= grid[x][y]; // å‡å»è‡ªå·±
        return sum;
    }

    // --- æ¸²æŸ“ ---
    function draw() {
        // èƒŒæ™¯
        ctx.fillStyle = '#0d1117';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç½‘æ ¼çº¿ (å¯é€‰ï¼Œå¤ªå¯†äº†å¯ä»¥ä¸ç”»ï¼Œæˆ–è€…ç”»æ·¡ä¸€ç‚¹)
        /*
        ctx.strokeStyle = '#161b22';
        ctx.beginPath();
        for (let i = 0; i < COLS; i++) ctx.moveTo(i * CELL_SIZE, 0), ctx.lineTo(i * CELL_SIZE, canvas.height);
        for (let j = 0; j < ROWS; j++) ctx.moveTo(0, j * CELL_SIZE), ctx.lineTo(canvas.width, j * CELL_SIZE);
        ctx.stroke();
        */

        // ç»†èƒ
        ctx.fillStyle = '#39d353';
        ctx.shadowBlur = 5; // å‘å…‰æ•ˆæœ
        ctx.shadowColor = '#39d353';
        
        for (let col = 0; col < COLS; col++) {
            for (let row = 0; row < ROWS; row++) {
                if (grid[col][row] === 1) {
                    ctx.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
                }
            }
        }
        ctx.shadowBlur = 0; // é‡ç½®
    }

    function loop(timestamp) {
        if (!isPlaying) return;

        const elapsed = timestamp - lastFrameTime;

        if (elapsed > frameInterval) {
            lastFrameTime = timestamp - (elapsed % frameInterval);
            update();
            draw();
        }

        animationId = requestAnimationFrame(loop);
    }

    // --- æ§åˆ¶ ---
    function togglePlay() {
        isPlaying = !isPlaying;
        playBtn.textContent = isPlaying ? 'â¸ æš‚åœ' : 'â–¶ è¿è¡Œ';
        playBtn.className = isPlaying ? '' : 'primary';
        
        if (isPlaying) {
            lastFrameTime = performance.now();
            loop();
        } else {
            cancelAnimationFrame(animationId);
        }
    }

    function step() {
        if (isPlaying) togglePlay();
        update();
        draw();
    }

    function clearGrid() {
        grid = createEmptyGrid();
        nextGrid = createEmptyGrid();
        generation = 0;
        population = 0;
        if (isPlaying) togglePlay();
        updateUI();
        draw();
    }

    function randomize() {
        clearGrid();
        for (let col = 0; col < COLS; col++) {
            for (let row = 0; row < ROWS; row++) {
                grid[col][row] = Math.random() > 0.85 ? 1 : 0; // 15% çš„å­˜æ´»ç‡
            }
        }
        draw();
    }

    function updateSpeed(val) {
        fps = parseInt(val);
        frameInterval = 1000 / fps;
    }
    
    function toggleMobilePresets() {
        mobilePresets.classList.toggle('show');
    }

    function updateUI() {
        genCountEl.textContent = generation;
        popCountEl.textContent = population;
    }

    // --- äº¤äº’ç»˜åˆ¶ ---
    let isDrawing = false;

    function getCellFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);
        return { col, row };
    }

    function toggleCell(e) {
        const { col, row } = getCellFromEvent(e);
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            grid[col][row] = 1; // é¼ æ ‡ç»è¿‡å˜æ´»
            draw();
        }
    }

    canvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        toggleCell(e);
    });
    canvas.addEventListener('mousemove', (e) => {
        if (isDrawing) toggleCell(e);
    });
    window.addEventListener('mouseup', () => isDrawing = false);

    // è§¦æ‘¸æ”¯æŒ
    canvas.addEventListener('touchstart', (e) => {
        isDrawing = true;
        toggleCell(e);
        e.preventDefault();
    }, {passive: false});
    canvas.addEventListener('touchmove', (e) => {
        if (isDrawing) toggleCell(e);
        e.preventDefault();
    }, {passive: false});
    window.addEventListener('touchend', () => isDrawing = false);

    // --- é¢„è®¾å›¾æ¡ˆ ---
    function loadPreset(type) {
        // clearGrid(); // ä¸æ¸…ç©ºï¼Œå…è®¸å åŠ 
        mobilePresets.classList.remove('show');
        
        const cx = Math.floor(COLS / 2);
        const cy = Math.floor(ROWS / 2);

        if (type === 'glider') {
            const pattern = [[0,1], [1,2], [2,0], [2,1], [2,2]];
            drawPattern(pattern, 5, 5); // å·¦ä¸Šè§’å‘å°„
        } else if (type === 'pulsar') {
            // ç®€åŒ–çš„è„‰å†²æ˜Ÿå¤ªéš¾ç”»äº†ï¼Œç”»ä¸ªç®€å•çš„ R-pentomino å§ï¼Œå®ƒèƒ½æ¼”åŒ–å¾ˆä¹…
            const pattern = [[0,1], [0,2], [1,0], [1,1], [2,1]]; 
            drawPattern(pattern, cx, cy);
        } else if (type === 'gun') {
            // Gosper Glider Gun
            const gun = [
                [0,4], [0,5], [1,4], [1,5],
                [10,4], [10,5], [10,6],
                [11,3], [11,7],
                [12,2], [12,8],
                [13,2], [13,8],
                [14,5],
                [15,3], [15,7],
                [16,4], [16,5], [16,6],
                [17,5],
                [20,2], [20,3], [20,4],
                [21,2], [21,3], [21,4],
                [22,1], [22,5],
                [24,0], [24,1], [24,5], [24,6],
                [34,2], [34,3], [35,2], [35,3]
            ];
            drawPattern(gun, 2, 10);
        }
        draw();
    }

    function drawPattern(coords, offsetX, offsetY) {
        coords.forEach(([x, y]) => {
            if (offsetX + x < COLS && offsetY + y < ROWS) {
                grid[offsetX + x][offsetY + y] = 1;
            }
        });
    }

    // å¯åŠ¨
    resize(); // åˆå§‹åŒ–å°ºå¯¸å¹¶å¼€å§‹

</script>
</body>
</html>
