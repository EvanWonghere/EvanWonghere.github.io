<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Snake</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --grid-line: #1a1a1a;
            --snake-head: #00ff88;
            --snake-body: #00cc6a;
            --food-color: #ff0055;
            --text-color: #00ff88;
            --panel-bg: rgba(0, 20, 10, 0.8);
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            touch-action: none; /* 禁止移动端默认滚动 */
        }

        /* UI 覆盖层 */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .score-board {
            display: flex;
            gap: 20px;
            font-size: 1.2rem;
            text-shadow: 0 0 10px var(--text-color);
        }

        /* 游戏结束/开始 菜单 */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }
        #menu-overlay.hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #ff00de, 0 0 40px #ff00de;
            animation: flicker 1.5s infinite alternate;
        }

        .btn {
            background: transparent;
            color: #fff;
            border: 2px solid #00ff88;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px #00ff88;
            transition: all 0.2s;
            margin-top: 20px;
        }
        .btn:hover {
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
        }

        /* CRT 扫描线效果 (复古滤镜) */
        .crt-lines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.1);
            border: 1px solid #333;
        }

        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% { text-shadow: 0 0 10px #fff, 0 0 20px #ff00de, 0 0 40px #ff00de; }
            20%, 24%, 55% { text-shadow: none; }
        }

        /* 移动端提示 */
        .mobile-hint {
            display: none;
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 10px;
        }
        @media (hover: none) {
            .mobile-hint { display: block; }
        }

    </style>
</head>
<body>

<div class="crt-lines"></div>

<div id="ui-layer">
    <div class="score-board">
        <div>SCORE: <span id="score">0</span></div>
        <div>BEST: <span id="best">0</span></div>
    </div>
</div>

<div id="menu-overlay">
    <h1>Neon Snake</h1>
    <p>WASD / Arrows / Swipe</p>
    <button class="btn" id="start-btn" onclick="startGame()">Start Game</button>
    <div class="mobile-hint">Swipe to move • Double tap to boost</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const menu = document.getElementById('menu-overlay');
    const startBtn = document.getElementById('start-btn');

    // --- 游戏配置 ---
    const GRID_SIZE = 20; // 网格大小
    let TILE_COUNT_X, TILE_COUNT_Y;
    
    let score = 0;
    let bestScore = localStorage.getItem('neon-snake-best') || 0;
    bestEl.textContent = bestScore;

    let gameRunning = false;
    let gameLoopId;
    let lastTime = 0;
    let speed = 5; // 每秒移动多少格 (初始速度)
    let speedMultiplier = 1;

    // 实体
    let snake = [];
    let velocity = { x: 0, y: 0 };
    let food = { x: 5, y: 5 };
    let particles = []; // 粒子特效数组

    // 输入缓冲 (防止一帧内按两次导致自杀)
    let inputQueue = [];

    // --- 初始化与自适应 ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        TILE_COUNT_X = Math.floor(canvas.width / GRID_SIZE);
        TILE_COUNT_Y = Math.floor(canvas.height / GRID_SIZE);
    }
    window.addEventListener('resize', resize);
    resize();

    function startGame() {
        if (gameRunning) return;
        
        // 初始化状态
        snake = [
            { x: Math.floor(TILE_COUNT_X / 2), y: Math.floor(TILE_COUNT_Y / 2) },
            { x: Math.floor(TILE_COUNT_X / 2), y: Math.floor(TILE_COUNT_Y / 2) + 1 },
            { x: Math.floor(TILE_COUNT_X / 2), y: Math.floor(TILE_COUNT_Y / 2) + 2 }
        ];
        velocity = { x: 0, y: -1 }; // 初始向上
        inputQueue = [];
        score = 0;
        speed = 8; // 初始速度
        scoreEl.textContent = 0;
        particles = [];
        
        spawnFood();
        
        menu.classList.add('hidden');
        gameRunning = true;
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        gameRunning = false;
        menu.classList.remove('hidden');
        startBtn.textContent = "Try Again";
        
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('neon-snake-best', bestScore);
            bestEl.textContent = bestScore;
        }
        
        // 死亡特效：全屏震动
        shakeScreen(10);
    }

    // --- 游戏主循环 ---
    function gameLoop(currentTime) {
        if (!gameRunning) return;

        const deltaTime = (currentTime - lastTime) / 1000;
        const moveInterval = 1 / (speed * speedMultiplier);

        // 1. 渲染背景
        drawBackground();

        // 2. 渲染粒子 (独立于帧率，保证流畅)
        updateAndDrawParticles();

        // 3. 蛇的移动逻辑 (基于时间步长)
        if (deltaTime >= moveInterval) {
            updateSnake();
            lastTime = currentTime;
        }

        // 4. 渲染实体 (插值渲染略，这里直接画)
        drawFood();
        drawSnake();

        requestAnimationFrame(gameLoop);
    }

    // --- 核心逻辑 ---
    function updateSnake() {
        // 处理输入队列
        if (inputQueue.length > 0) {
            const nextDir = inputQueue.shift();
            // 禁止掉头
            if (nextDir.x !== -velocity.x && nextDir.y !== -velocity.y) {
                velocity = nextDir;
            } else if (inputQueue.length > 0) {
                // 如果第一个输入无效(掉头)，尝试处理下一个
                const nextNextDir = inputQueue.shift();
                if (nextNextDir.x !== -velocity.x && nextNextDir.y !== -velocity.y) {
                    velocity = nextNextDir;
                }
            }
        }

        // 移动头部
        const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

        // 穿墙处理 (赛博朋克通常是无限循环地图)
        if (head.x < 0) head.x = TILE_COUNT_X - 1;
        if (head.x >= TILE_COUNT_X) head.x = 0;
        if (head.y < 0) head.y = TILE_COUNT_Y - 1;
        if (head.y >= TILE_COUNT_Y) head.y = 0;

        // 碰撞检测 (撞自己)
        for (let part of snake) {
            if (head.x === part.x && head.y === part.y) {
                gameOver();
                return;
            }
        }

        snake.unshift(head); // 加头

        // 吃到食物
        if (head.x === food.x && head.y === food.y) {
            score += 10;
            scoreEl.textContent = score;
            // 难度增加：每吃一个，速度微增
            speed = Math.min(speed + 0.2, 25); 
            
            spawnParticles(head.x * GRID_SIZE + GRID_SIZE/2, head.y * GRID_SIZE + GRID_SIZE/2, '#ff0055');
            spawnFood();
            // 这里不 pop 尾巴，蛇就变长了
        } else {
            snake.pop(); // 去尾
        }
    }

    function spawnFood() {
        // 简单的随机生成，防止生成在蛇身上
        let valid = false;
        while (!valid) {
            food = {
                x: Math.floor(Math.random() * TILE_COUNT_X),
                y: Math.floor(Math.random() * TILE_COUNT_Y)
            };
            valid = !snake.some(part => part.x === food.x && part.y === food.y);
        }
    }

    // --- 粒子系统 ---
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.decay = Math.random() * 0.03 + 0.02;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function spawnParticles(x, y, color) {
        for (let i = 0; i < 15; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function updateAndDrawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.update();
            p.draw(ctx);
            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    // --- 渲染系统 ---
    function drawBackground() {
        // 清屏 (带一点透明度，形成拖尾残影效果，更有速度感)
        ctx.fillStyle = "rgba(5, 5, 5, 0.3)"; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 画复古网格
        ctx.strokeStyle = "#1a1a1a";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
            ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
        }
        for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
            ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
    }

    function drawSnake() {
        // 霓虹发光特效
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#00ff88";
        
        // 画蛇身
        ctx.fillStyle = "#00cc6a";
        for (let i = 1; i < snake.length; i++) {
            const part = snake[i];
            // 稍微留点缝隙
            ctx.fillRect(part.x * GRID_SIZE + 1, part.y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
        }

        // 画蛇头 (亮一点)
        const head = snake[0];
        ctx.fillStyle = "#00ff88";
        ctx.shadowBlur = 25; // 头更亮
        ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        
        // 重置阴影，防止影响其他元素
        ctx.shadowBlur = 0;
    }

    function drawFood() {
        const x = food.x * GRID_SIZE + GRID_SIZE / 2;
        const y = food.y * GRID_SIZE + GRID_SIZE / 2;

        ctx.shadowBlur = 20;
        ctx.shadowColor = "#ff0055";
        ctx.fillStyle = "#ff0055";
        
        // 呼吸动画
        const pulse = Math.sin(Date.now() / 200) * 2;

        ctx.beginPath();
        ctx.arc(x, y, (GRID_SIZE / 2) - 2 + pulse, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
    }

    // --- 交互控制 ---
    
    // 键盘
    document.addEventListener('keydown', (e) => {
        // 防止方向键滚动页面
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
            e.preventDefault();
        }

        let newDir = null;
        switch (e.key) {
            case 'ArrowUp': case 'w': case 'W': newDir = { x: 0, y: -1 }; break;
            case 'ArrowDown': case 's': case 'S': newDir = { x: 0, y: 1 }; break;
            case 'ArrowLeft': case 'a': case 'A': newDir = { x: -1, y: 0 }; break;
            case 'ArrowRight': case 'd': case 'D': newDir = { x: 1, y: 0 }; break;
            case ' ': // 空格加速
                speedMultiplier = 2; 
                break;
        }
        if (newDir) inputQueue.push(newDir);
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === ' ') speedMultiplier = 1;
    });

    // 触摸手势 (Swipe)
    let touchStartX = 0;
    let touchStartY = 0;

    document.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, {passive: false});

    document.addEventListener('touchmove', (e) => {
        e.preventDefault(); // 阻止滑动页面
    }, {passive: false});

    document.addEventListener('touchend', (e) => {
        const touchEndX = e.changedTouches[0].screenX;
        const touchEndY = e.changedTouches[0].screenY;
        
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;

        if (Math.abs(dx) > Math.abs(dy)) {
            if (Math.abs(dx) > 20) inputQueue.push(dx > 0 ? {x: 1, y: 0} : {x: -1, y: 0});
        } else {
            if (Math.abs(dy) > 20) inputQueue.push(dy > 0 ? {x: 0, y: 1} : {x: 0, y: -1});
        }
    }, {passive: false});

    // 屏幕震动特效
    function shakeScreen(intensity) {
        const body = document.body;
        body.style.transform = `translate(${Math.random()*intensity-intensity/2}px, ${Math.random()*intensity-intensity/2}px)`;
        setTimeout(() => {
            if (intensity > 1) shakeScreen(intensity * 0.9);
            else body.style.transform = 'none';
        }, 50);
    }

</script>
</body>
</html>
