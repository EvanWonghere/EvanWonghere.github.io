<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="这是当年在实验室给新生培训的课件，也顺便搬过来了。做了点微小修订，也懒得全部更新了。当年为了给新生上压力，使用了全英文的课件。"><title>实验室 C++ 基础课程 · 第一章第三节</title><link rel=canonical href=https://yufenghuang.tech/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="实验室 C++ 基础课程 · 第一章第三节"><meta property='og:description' content="这是当年在实验室给新生培训的课件，也顺便搬过来了。做了点微小修订，也懒得全部更新了。当年为了给新生上压力，使用了全英文的课件。"><meta property='og:url' content='https://yufenghuang.tech/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82/'><meta property='og:site_name' content='蜂窝'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='C++'><meta property='article:tag' content='LearningNote'><meta property='article:tag' content='学习笔记'><meta property='article:published_time' content='2023-10-24T00:00:00+00:00'><meta property='article:modified_time' content='2023-10-24T00:00:00+00:00'><meta name=twitter:title content="实验室 C++ 基础课程 · 第一章第三节"><meta name=twitter:description content="这是当年在实验室给新生培训的课件，也顺便搬过来了。做了点微小修订，也懒得全部更新了。当年为了给新生上压力，使用了全英文的课件。"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_789ebd951ab60789.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🐝</span></figure><div class=site-meta><h1 class=site-name><a href=/>蜂窝</a></h1><h2 class=site-description>EvanWong的个人博客</h2></div></header><ol class=menu-social><li><a href=https://github.com/EvanWonghere/EvanWonghere.github.io target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://steamcommunity.com/profiles/76561198980535015/ target=_blank title=Steam rel=me><svg role="img" viewBox="0 0 24 24"><title>Steam</title><path d="M11.979.0C5.678.0.511 4.86.022 11.037l6.432 2.658c.545-.371 1.203-.59 1.912-.59.063.0.125.004.188.006l2.861-4.142V8.91c0-2.495 2.028-4.524 4.524-4.524 2.494.0 4.524 2.031 4.524 4.527s-2.03 4.525-4.524 4.525h-.105l-4.076 2.911c0 .052.004.105.004.159.0 1.875-1.515 3.396-3.39 3.396-1.635.0-3.016-1.173-3.331-2.727L.436 15.27C1.862 20.307 6.486 24 11.979 24c6.627.0 11.999-5.373 11.999-12S18.605.0 11.979.0zM7.54 18.21l-1.473-.61c.262.543.714.999 1.314 1.25 1.297.539 2.793-.076 3.332-1.375.263-.63.264-1.319.005-1.949s-.75-1.121-1.377-1.383c-.624-.26-1.29-.249-1.878-.03l1.523.63c.956.4 1.409 1.5 1.009 2.455-.397.957-1.497 1.41-2.454 1.012H7.54zm11.415-9.303c0-1.662-1.353-3.015-3.015-3.015-1.665.0-3.015 1.353-3.015 3.015.0 1.665 1.35 3.015 3.015 3.015 1.663.0 3.015-1.35 3.015-3.015zm-5.273-.005c0-1.252 1.013-2.266 2.265-2.266 1.249.0 2.266 1.014 2.266 2.266.0 1.251-1.017 2.265-2.266 2.265-1.253.0-2.265-1.014-2.265-2.265z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/quotes/><svg fill="#000" width="800" height="800" viewBox="-6 0 32 32"><title>quote-right</title><path d="M3.44 22.8c-.32.0-.64-.2-.76-.52-.16-.44.04-.92.48-1.08 3.4-1.36 4.12-4.28 4.12-6.48.0-2.52-1.4-3.84-2.8-3.84-1.28.0-2.8.6-2.8 2.28.0.68.36 1.32.96 1.72.48.28 1.04.36 1.44.12.4-.2.92-.04 1.12.36s.04.92-.36 1.12c-.96.48-2.12.4-3.08-.2-1.12-.68-1.76-1.84-1.76-3.12.0-2.32 1.84-3.96 4.48-3.96 2.16.0 4.48 1.92 4.48 5.52.0 3.84-1.84 6.68-5.2 8.04-.08.0-.2.04-.32.04zM14 22.8c-.32.0-.64-.2-.76-.52-.16-.44.04-.92.48-1.08 3.4-1.36 4.12-4.28 4.12-6.48.0-2.52-1.4-3.84-2.8-3.84-1.28.0-2.8.6-2.8 2.28.0.68.36 1.32.96 1.72.48.28 1.04.36 1.44.12.4-.2.92-.04 1.12.36s.04.92-.36 1.12c-.96.48-2.12.4-3.08-.2-1.08-.68-1.76-1.84-1.76-3.12.0-2.32 1.84-3.96 4.48-3.96 2.16.0 4.48 1.92 4.48 5.52.0 3.84-1.84 6.68-5.2 8.04-.12.0-.24.04-.32.04z"/></svg>
<span>采撷集</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://yufenghuang.tech/en/>English</option><option value=https://yufenghuang.tech/ selected>中文</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#chapter-1--hello-c>Chapter 1 —— Hello, C++!</a><ol><li><a href=#basic-syntax>Basic syntax</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82/>实验室 C++ 基础课程 · 第一章第三节</a></h2><h3 class=article-subtitle>这是当年在实验室给新生培训的课件，也顺便搬过来了。做了点微小修订，也懒得全部更新了。当年为了给新生上压力，使用了全英文的课件。</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 24, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 9 分钟</time></div></footer></div></header><section class=article-content><h1 id=c-basic-course>C++ Basic Course</h1><h2 id=chapter-1--hello-c>Chapter 1 —— Hello, C++!</h2><h3 id=basic-syntax>Basic syntax</h3><p><em><strong>Our goal is to completely understand the code below!</strong></em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span><span class=lnt>95
</span><span class=lnt>96
</span><span class=lnt>97
</span><span class=lnt>98
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;typeinfo&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Function prototypes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>swapPointer</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>swapReference</span><span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span><span class=p>,</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Inline function to print variable values
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>output</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>p</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>q</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>p</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;b: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>q</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Enter two integers: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>a</span> <span class=o>&gt;&gt;</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Before swap: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Address of a: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>&amp;</span><span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address of b: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>&amp;</span><span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After swap(int, int): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After swap(int*, int*): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>swapPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After swapPointer(int*, int*): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>swapReference</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After swapReference(int&amp;, int&amp;): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Value-passing version
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;In function swap(int, int): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;a: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;b: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address of a: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>&amp;</span><span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address of b: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>&amp;</span><span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Pointer-passing version
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>decltype</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;In function swap(int*, int*) after swap: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;type of tmp: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>typeid</span><span class=p>(</span><span class=n>tmp</span><span class=p>).</span><span class=n>name</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address that a points to: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address that b points to: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Value that the address a points to stored: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Value that the address b points to stored: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Pointer-passing version
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>swapPointer</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;In function swapPointer(int*, int*) after swap: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address that a points to: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address that b points to: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Value that the address a points to stored: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Value that the address b points to stored: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Reference-passing version
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>swapReference</span><span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;In function swapReference(int&amp;, int&amp;) after swap: &#34;</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;type of tmp: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>typeid</span><span class=p>(</span><span class=n>tmp</span><span class=p>).</span><span class=n>name</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;a: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;b: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address of a &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>&amp;</span><span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;Address of b &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>&amp;</span><span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>The C++ Preprocessor</strong></em></p><p>​ C++, like C, uses a <em><strong>preprocessor</strong></em>. This is a program that processes a source file before the main compilation takes place. You don’t have to do anything special to invoke this preprocessor. It automatically operates when you compile the program.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>		</span><span class=c1>// a PREPROCESSOR directive
</span></span></span></code></pre></td></tr></table></div></div><p>​ This directive causes the preprocessor to add the contents of the iostream file to your program. This is a typical preprocessor action: adding or replacing text in the source code before it’s compiled. In essence, the contents of the iostream file replace the <code>#include &lt;iostream></code> line in the program. <strong>Your original file is not altered, but a composite file formed from your file and iostream goes on to the next stage of compilation.</strong></p></li><li><p><em><strong>header</strong></em></p><div class=table-wrapper><table><thead><tr><th>Kind of header</th><th>Convention</th><th>Example</th><th>Comments</th></tr></thead><tbody><tr><td>C++ old style</td><td>Ends in <code>.h</code></td><td><code>iostream.h</code></td><td>Usable by C++ programs</td></tr><tr><td>C old style</td><td>Ends in <code>.h</code></td><td><code>math.h</code></td><td>Usable by C and C++ programs</td></tr><tr><td>C++ new style</td><td>No extension</td><td><code>iostream</code></td><td>Usable by C++ programs, uses <code>namespace std</code></td></tr><tr><td>Converted C</td><td><code>c</code> prefix, no extension</td><td><code>cmath</code></td><td>Usable by C++ programs, might use non-C features, such as <code>namespace std</code></td></tr></tbody></table></div></li><li><p><em><strong>namespace</strong></em></p><p>​ Namespace support is a C++ feature designed to simplify the writing of large programs and of programs that combine pre-existing code from several vendors and to help organize programs.</p><p>​ One potential problem is that you might use two prepackaged products that both have, say, a function called <code>wanda()</code>. If you then use the <code>wanda()</code> function, the compiler won’t know which version you mean.</p><p>​ The namespace facility lets a vendor package its wares in a unit called a <em><strong>namespace</strong></em> so that you can use the name of a namespace to indicate which vendor’s product you want. So Microflop Industries could place its definitions in a namespace called <code>Microflop</code>.Then <code>Microflop::wanda()</code> would become the full name for its wanda() function. Similarly, <code>Piscine::wanda()</code> could denote Piscine Corporation’s version of wanda().</p><p>​ Thus, your program could now use the namespaces to discriminate between various versions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Microflop</span><span class=o>::</span><span class=n>wanda</span><span class=p>(</span><span class=s>&#34;go dancing?&#34;</span><span class=p>);</span>		<span class=c1>// use Microflop namespace version
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Piscine</span><span class=o>::</span><span class=n>wanda</span><span class=p>(</span><span class=s>&#34;a fish named Desire&#34;</span><span class=p>)</span>	<span class=c1>// use Piscine namespace version
</span></span></span></code></pre></td></tr></table></div></div><p>​ The using directive like <code>using namespace std</code> makes all the names in the <code>std</code> namespace available. Modern practice regards this as a bit lazy and potentially a problem in large projects. The preferred approaches are to use the std:: qualifier or to use something called a using declaration to make just particular names available:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>​ However, for me, it is more customary not to use the using directive.</p><p>​ In addition, the using directive can also give aliases to types:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>i64</span> <span class=o>=</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>​ It is somewhat similar to <code>#define LL long long</code>, but still different:</p><ul><li><p><em><strong>Scope:</strong></em> &ldquo;using i64 = long long;&rdquo; is the syntax for creating a type alias in C++, and its scope is limited to the current namespace or scope. On the other hand, &ldquo;#define i64 long long&rdquo; is a preprocessing directive in C and C++ that performs text replacement during the preprocessing phase, and its scope extends throughout the entire source file.</p></li><li><p><em><strong>Type Safety:</strong></em> &ldquo;using i64 = long long;&rdquo; preserves type safety when creating a type alias. &ldquo;i64&rdquo; and &ldquo;long long&rdquo; are essentially the same type with just a different name. This means that when using &ldquo;i64,&rdquo; the compiler performs type checking to ensure that only &ldquo;long long&rdquo; operations are allowed.</p><p>&ldquo;#define i64 long long&rdquo; is a simple text replacement and lacks type checking. When using &ldquo;i64,&rdquo; the preprocessor replaces all occurrences of &ldquo;i64&rdquo; with &ldquo;long long&rdquo; without performing type checks.</p></li><li><p><em><strong>Life time:</strong></em> The type alias created with &ldquo;using i64 = long long;&rdquo; remains valid for the entire lifetime of the program and can be used anywhere in the code. In contrast, the text replacement performed by &ldquo;#define i64 long long&rdquo; is only effective within the current source file and does not affect other files.</p></li></ul></li><li><p><em><strong>comments</strong></em></p><p>​ The <em><strong>double slash (//)</strong></em> introduces a C++ comment. A comment is a remark from the programmer to the reader that usually identifies a section of a program or explains some aspect of the code. The compiler ignores comments.</p><ul><li><p>C++ also recognizes C comments, which are enclosed between /* and */ symbols:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp> </span><span class=cm>/* a C-style comment */</span><span class=cp>
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><em><strong>cout && cin</strong></em></p><p>​ For now, you only need to know that <code>cin</code> is used for <strong>input</strong>, similar to <code>scanf</code>, and <code>cout</code> is used for <strong>output</strong>, similar to <code>printf</code>. We will explain it in more depth when we reach <em><strong>stream</strong></em> in the lesson.</p><p>​ You can currently understand it this way, <code>cout</code> and <code>cin</code> are both intelligent and do not need to specify the type. <code>&lt;&lt;</code> is the output operator and <code>>></code> is the read operator. The input and output can be spliced through corresponding operators. For example, <code>std::cin >> a >> b;</code> is to read the two values a and b; <code>std::cout &lt;&lt; a &lt;&lt; b;</code> is to output a, b these two values.</p><p>​ Moreover, C++’s free format rules treat newlines and spaces between tokens interchangeably, so you can write code like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>		 <span class=o>&gt;&gt;</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a is: &#34;</span>
</span></span><span class=line><span class=cl>		  <span class=o>&lt;&lt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>		  <span class=o>&lt;&lt;</span> <span class=s>&#34;, and b is: &#34;</span>
</span></span><span class=line><span class=cl>		  <span class=o>&lt;&lt;</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>		  <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>The Manipulator <em><strong>endl</strong></em></p><p>​ <code>endl</code> is a special C++ notation that represents the important concept of beginning a new line. Special notations like endl that have particular meanings to cout are dubbed manipulators. Like cout, endl is defined in the iostream header file and is part of the <code>std namespace</code>.</p><p>​ Note that the cout facility does not move automatically to the next line when it prints a string, the output for each cout statement begins where the last output ended.</p><p>​ You can still use <code>\n</code> in C++</p></li><li><p>Other <em><strong>manipulators</strong></em></p><ol><li><code>std::setw</code> - Set the field width for the next output.</li><li><code>std::setprecision</code> - Set the decimal precision for floating-point output.</li><li><code>std::setfill</code> - Set the fill character used for padding.</li><li><code>std::left</code> and <code>std::right</code> - Set the text alignment for output.</li><li><code>std::fixed</code> - Display floating-point numbers in fixed-point notation.</li><li><code>std::scientific</code> - Display floating-point numbers in scientific (exponential) notation.</li><li><code>std::boolalpha</code> - Display boolean values as &ldquo;true&rdquo; or &ldquo;false&rdquo; instead of 1 or 0.</li><li><code>std::uppercase</code> - Output letters in uppercase.</li><li><code>std::nouppercase</code> - Output letters in lowercase.</li><li><code>std::showpos</code> - Always show the plus sign for positive numbers.</li><li><code>std::noshowpos</code> - Do not show the plus sign for positive numbers.</li><li><code>std::hex</code>, <code>std::oct</code>, and <code>std::dec</code> - Set the output base (hexadecimal, octal, or decimal).</li><li><code>std::setbase</code> - Set the base for numeric input and output.</li><li><code>std::noskipws</code> - Disable skipping of leading whitespace when reading from input.</li></ol></li></ul></li><li><p><em><strong>function</strong></em></p><p>​ Because functions are the modules from which C++ programs are built and because they are essential to C++ OOP definitions, you should become thoroughly familiar with them. Some aspects of functions are advanced topics, so the main discussion of functions comes later (maybe).</p><p>​ However, if we deal now with some basic characteristics of functions, you’ll be more at ease and more practiced with functions later.</p><ul><li><p><em><strong>function form</strong></em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>returnType</span> <span class=nf>functionName</span><span class=p>(</span><span class=n>argumentList</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>statements</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>​ If return type is <code>void</code>, that means the function returns nothing, you can use <code>return;</code> statement to end the function, or let the program run to the end of the function automatically.</p><p>​ Similarly, if the argument is <code>void</code>, then it means that the arguments are not accepted, and <code>foo(void)</code> and <code>foo()</code> have the same meaning.</p><p>​ However, it should be noted that in C, the argumentList is empty, which means silence to accept arguments, rather than not accepting the arguments, unless explicitly declared as <code>foo(void)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>foo</span><span class=p>()</span> <span class=p>{</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Function running</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>foo</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// In C++
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>error</span><span class=p>:</span> <span class=n>too</span> <span class=n>many</span> <span class=n>arguments</span> <span class=n>to</span> <span class=n>function</span> <span class=err>&#39;</span><span class=kt>void</span> <span class=n>foo</span><span class=p>()</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>     <span class=n>foo</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>declared</span> <span class=n>here</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>foo</span><span class=p>()</span> <span class=p>{</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Function running</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* In C */</span>
</span></span><span class=line><span class=cl><span class=n>Function</span> <span class=n>running</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><em><strong>function header</strong></em></p><p>​ The <code>output()</code> function in code has this header</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>output</span><span class=p>(</span><span class=kt>int</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>q</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>​ As we said before, the initial void means that little poor <code>output()</code> has no return value. So you can&rsquo;t use it this way:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>var</span> <span class=o>=</span> <span class=n>output</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=err>&#39;</span><span class=kt>void</span> <span class=n>var</span><span class=err>&#39;</span> <span class=n>has</span> <span class=n>incomplete</span> <span class=n>type</span>
</span></span><span class=line><span class=cl>   <span class=mi>21</span> <span class=o>|</span>     <span class=k>auto</span> <span class=n>var</span> <span class=o>=</span> <span class=n>output</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>​ The <code>int p, int q</code> within the parentheses means that you are expected to use <code>output()</code> with two arguments of type int. The <code>p, q</code> are new variables assigned the value passed during a function call.</p><p>​ What&rsquo;s more, <code>a, b</code> in the function call are <code>argument / actual parameter</code>, <code>p, q</code> in the function header are <code>parameter / formal parameter</code>. In function prototypes, the name of the <code>parameter / formal parameter</code> can be ignored, you just need to keep the types.</p></li><li><p><em><strong>recursion</strong></em></p><p>​ And now for something completely different. A C++ function has the interesting characteristic that it can call itself. (Unlike C, however, C++ does not let main() call itself.) This ability is termed recursion. In computer science, <strong>recursion</strong> is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. Recursion is an important tool in certain types of programming, such as artificial intelligence, Depth-First Search, Breadth-First Search, but we’ll just take a superficial look (artificial shallowness) at how it works.</p><p>​ A recursive function definition has one or more <em>base cases</em>, meaning input(s) for which the function produces a result trivially (without recurring), and one or more <em>recursive cases</em>, meaning input(s) for which the program recurs (calls itself).</p><p>​ If a recursive function calls itself, then the newly called function calls itself, and so on, ad infinitum unless the code includes something to terminate the chain of calls (<strong>base cases</strong>). The usual method is to make the recursive call part of an <code>if</code> statement. For example, a type <code>void </code>recursive function called <code>recurs()</code> can have a form like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl> <span class=kt>void</span> <span class=nf>recurs</span><span class=p>(</span><span class=n>argumentList</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=n>statements1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=k>if</span> <span class=p>(</span><span class=n>test</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=n>recurs</span><span class=p>(</span><span class=n>arguments</span><span class=p>);</span>
</span></span><span class=line><span class=cl>     <span class=n>statements2</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><em><strong>inline</strong></em></p><p>​ Inline functions are a C++ enhancement designed to speed up programs. The primary distinction between normal functions and inline functions is not in how you code them but in how the C++ compiler incorporates them into a program. To understand the distinction between inline functions and normal functions, you need to peer more deeply into a program’s innards than we have so far. So we won’t go into too deep an explanation, just briefly talk about the differences.</p><p>​ For ordinary functions, when the function is called, the program will jump to the function to continue execution, and then jump back after executing the function. Jumping back and forth and keeping track of where to jump means that there is an overhead in elapsed time to using functions.</p><p>​ C++ inline functions provide an alternative. In an inline function, the compiled code is “in line” with the other code in the program. That is, the compiler replaces the function call with the corresponding function code. With inline code, the program doesn’t have to jump to another location to execute the code and then jump back.</p><p>​ Inline functions thus run a little faster than regular functions, but they come with a memory penalty. If a program calls an inline function at ten separate locations, then the program winds up with ten copies of the function inserted into the code.</p><p><img src=/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82/inline.png width=1316 height=1276 srcset="/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82/inline_hu_e1f953deb7b4c494.png 480w, /p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82/inline_hu_4c07aba0936224e1.png 1024w" loading=lazy alt="inline Function" class=gallery-image data-flex-grow=103 data-flex-basis=247px></p><p>​ You should be selective about using inline functions. If the time needed to execute the function code is long compared to the time needed to handle the function call mechanism, then the time saved is a relatively small portion of the entire process.</p><p>​ If the code execution time is short, then an inline call can save a large portion of the time used by the non-inline call. On the other hand, you are now saving a large portion of a relatively quick process, so the absolute time savings may not be that great unless the function is called frequently.</p><p>​ To use this feature, you must take at least one of two actions:</p><ul><li><p>Preface the function declaration with the keyword <code>inline</code>.</p></li><li><p>Preface the function definition with the keyword <code>inline</code>.</p><p>It should be noted that inline functions cannot be recursive, or recursive functions cannot be inline with the keyword</p></li></ul></li><li><p><em><strong>default arguments</strong></em></p><p>​ Let’s look at another topic from C++’s bag of new tricks: the default argument. A default argument is a value that’s used automatically if you omit the corresponding actual argument from a function call. For example, if you set up void wow(int n) so that n has a default value of 1, the function call wow() is the same as wow(1).This gives you flexibility in how you use a function.</p><p>​ How do you establish a default value? You must use the function prototype. Because the compiler looks at the prototype to see how many arguments a function uses, the function prototype also has to alert the program to the possibility of default arguments. The method is to assign a value to the argument in the prototype.</p><p>​ When you use a function with an argument list, you must add defaults from right to left.That is, you can’t provide a default value for a particular argument unless you also provide defaults for all the arguments to its right:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>harpo</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>5</span><span class=p>);</span> 	  <span class=c1>// VALID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>chico</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=mi>6</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>);</span>			  <span class=c1>// INVALID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>groucho</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>3</span><span class=p>);</span> <span class=c1>// VALID
</span></span></span></code></pre></td></tr></table></div></div><p>For example, the harpo() prototype permits calls with one, two, or three arguments:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>beeps</span> <span class=o>=</span> <span class=n>harpo</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> 	   <span class=c1>// same as harpo(2,4,5)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>beeps</span> <span class=o>=</span> <span class=n>harpo</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>8</span><span class=p>);</span>    <span class=c1>// same as harpo(1,8,5)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>beeps</span> <span class=o>=</span> <span class=n>harpo</span> <span class=p>(</span><span class=mi>8</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>6</span><span class=p>);</span> <span class=c1>// no default arguments used
</span></span></span></code></pre></td></tr></table></div></div><p>​ The actual arguments are assigned to the corresponding formal arguments from left to right; you can’t skip over arguments. Thus, the following isn’t allowed:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>beeps</span> <span class=o>=</span> <span class=n>harpo</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=p>,</span><span class=mi>8</span><span class=p>);</span> <span class=c1>// invalid, doesn&#39;t set m to 4
</span></span></span></code></pre></td></tr></table></div></div><p>​ Default arguments aren’t a major programming breakthrough; rather, they are a convenience. When you begin working with class design, you’ll find that they can reduce the number of constructors, methods,and method overloads you have to define.</p><p>​ Note that only the prototype indicates the default. The function definition is the same as it would be without default arguments</p></li><li><p><em><strong>function polymorphism / function overloading</strong></em></p><p>​ In C, you are not allowed to write the code like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err>```</span>
</span></span><span class=line><span class=cl><span class=nf>swap</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></td></tr></table></div></div><p>​ You&rsquo;ll get a bunch of error:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>conflicting</span> <span class=n>types</span> <span class=k>for</span> <span class=err>&#39;</span><span class=n>swap</span><span class=err>&#39;</span><span class=p>;</span> <span class=n>have</span> <span class=err>&#39;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=mi>4</span> <span class=o>|</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>      <span class=o>^~~~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>previous</span> <span class=n>declaration</span> <span class=n>of</span> <span class=err>&#39;</span><span class=n>swap</span><span class=err>&#39;</span> <span class=n>with</span> <span class=n>type</span> <span class=err>&#39;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span>  <span class=kt>int</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=mi>3</span> <span class=o>|</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>      <span class=o>^~~~</span>
</span></span><span class=line><span class=cl><span class=n>In</span> <span class=n>function</span> <span class=err>&#39;</span><span class=n>main</span><span class=err>&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=nl>warning</span><span class=p>:</span> <span class=n>passing</span> <span class=n>argument</span> <span class=mi>1</span> <span class=n>of</span> <span class=err>&#39;</span><span class=n>swap</span><span class=err>&#39;</span> <span class=n>makes</span> <span class=n>pointer</span> <span class=n>from</span> <span class=n>integer</span> <span class=n>without</span> <span class=n>a</span> <span class=n>cast</span> <span class=p>[</span><span class=o>-</span><span class=n>Wint</span><span class=o>-</span><span class=n>conversion</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=mi>9</span> <span class=o>|</span>     <span class=nf>swap</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>          <span class=o>^</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>          <span class=o>|</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>          <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>expected</span> <span class=err>&#39;</span><span class=kt>int</span> <span class=o>*</span><span class=err>&#39;</span> <span class=n>but</span> <span class=n>argument</span> <span class=n>is</span> <span class=n>of</span> <span class=n>type</span> <span class=err>&#39;</span><span class=kt>int</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=mi>4</span> <span class=o>|</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>           <span class=o>^~~~</span>
</span></span><span class=line><span class=cl><span class=nl>warning</span><span class=p>:</span> <span class=n>passing</span> <span class=n>argument</span> <span class=mi>2</span> <span class=n>of</span> <span class=err>&#39;</span><span class=n>swap</span><span class=err>&#39;</span> <span class=n>makes</span> <span class=n>pointer</span> <span class=n>from</span> <span class=n>integer</span> <span class=n>without</span> <span class=n>a</span> <span class=n>cast</span> <span class=p>[</span><span class=o>-</span><span class=n>Wint</span><span class=o>-</span><span class=n>conversion</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=mi>9</span> <span class=o>|</span>     <span class=nf>swap</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>             <span class=o>^</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>             <span class=o>|</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>             <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>expected</span> <span class=err>&#39;</span><span class=kt>int</span> <span class=o>*</span><span class=err>&#39;</span> <span class=n>but</span> <span class=n>argument</span> <span class=n>is</span> <span class=n>of</span> <span class=n>type</span> <span class=err>&#39;</span><span class=kt>int</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=mi>4</span> <span class=o>|</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>                 <span class=o>^~~~</span>
</span></span><span class=line><span class=cl><span class=n>At</span> <span class=n>top</span> <span class=nl>level</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>conflicting</span> <span class=n>types</span> <span class=k>for</span> <span class=err>&#39;</span><span class=n>swap</span><span class=err>&#39;</span><span class=p>;</span> <span class=n>have</span> <span class=err>&#39;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>   <span class=mi>19</span> <span class=o>|</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>      <span class=o>^~~~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>previous</span> <span class=n>definition</span> <span class=n>of</span> <span class=err>&#39;</span><span class=n>swap</span><span class=err>&#39;</span> <span class=n>with</span> <span class=n>type</span> <span class=err>&#39;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span>  <span class=kt>int</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>   <span class=mi>15</span> <span class=o>|</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>      <span class=o>^~~~</span>
</span></span></code></pre></td></tr></table></div></div><p>​ But just like you saw before, it&rsquo;s not only allowed in C++, but also very very very widely used.</p><p>​ <em><strong>Function polymorphism</strong></em> is a neat C++ addition to C’s capabilities. Whereas default arguments let you call the same function by using varying numbers of arguments, function polymorphism, also called <em><strong>function overloading</strong></em>, lets you use multiple functions sharing the same name.</p><p>​ The word polymorphism means having many forms, so function polymorphism lets a function have many forms. Similarly, the expression function overloading means you can attach more than one function to the same name, thus overloading the name. Both expressions boil down to the same thing, but we’ll usually use the expression function overloading—it sounds harder working. You can use function overloading to design a family of functions that do essentially the same thing but using different argument lists.</p><p>​ The key to function overloading is a function’s argument list, also called the <em><strong>function signature</strong></em>. If two functions use the same number and types of arguments in the same order, they have the same signature; the variable names don’t matter.</p><p>​ C++ enables you to define two functions by the same name, provided that the functions have different signatures. The signature can differ in the number of arguments or in the type of arguments, or both. For example, you can define a set of print() functions with the following prototypes:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>	<span class=c1>// #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>double</span> <span class=n>d</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>		<span class=c1>// #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>long</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>			<span class=c1>// #3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>			<span class=c1>// #4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>);</span>			<span class=c1>// #5
</span></span></span></code></pre></td></tr></table></div></div><p>​ When you then use a print() function, the compiler matches your use to the prototype that has the same signature:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>print</span><span class=p>(</span><span class=s>&#34;Pancakes&#34;</span><span class=p>,</span> <span class=mi>15</span><span class=p>);</span>		<span class=c1>// use #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print</span><span class=p>(</span><span class=s>&#34;Syrup&#34;</span><span class=p>);</span>				<span class=c1>// use #5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print</span><span class=p>(</span><span class=mf>1999.0</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>			<span class=c1>// use #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print</span><span class=p>(</span><span class=mi>1999</span><span class=p>,</span> <span class=mi>12</span><span class=p>);</span>			<span class=c1>// use #4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print</span><span class=p>(</span><span class=mi>1999L</span><span class=p>,</span> <span class=mi>15</span><span class=p>);</span>			<span class=c1>// use #3
</span></span></span></code></pre></td></tr></table></div></div><p>​ When you use overloaded functions, you need to be sure you use the proper argument types in the function call. For example, consider the following statements:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>year</span> <span class=o>=</span> <span class=mi>2023</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>print</span><span class=p>(</span><span class=n>year</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span>				<span class=c1>// ambiguous call
</span></span></span></code></pre></td></tr></table></div></div><p>​ Which prototype does the print() call match here? It doesn’t match any of them! A lack of a matching prototype doesn’t automatically rule out using one of the functions because C++ will try to use standard type conversions to force a match.</p><p>​ If, say, the only print() prototype were #2, the function call print(year, 6) would convert the year value to type double. But in the earlier code there are three prototypes that take a number as the first argument, providing three different choices for converting year. Faced with this ambiguous situation, C++ rejects the function call as an error.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>call</span> <span class=n>of</span> <span class=n>overloaded</span> <span class=err>&#39;</span><span class=n>print</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=err>&#39;</span> <span class=n>is</span> <span class=n>ambiguous</span>
</span></span><span class=line><span class=cl>   <span class=mi>19</span> <span class=o>|</span>     <span class=n>print</span><span class=p>(</span><span class=n>year</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>     <span class=o>~~~~~^~~~~~~~~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=nl>candidate</span><span class=p>:</span> <span class=err>&#39;</span><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=kt>double</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>   <span class=mi>10</span> <span class=o>|</span> <span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=kt>double</span> <span class=n>d</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>      <span class=o>^~~~~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=nl>candidate</span><span class=p>:</span> <span class=err>&#39;</span><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=kt>long</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>   <span class=mi>11</span> <span class=o>|</span> <span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=kt>long</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>      <span class=o>^~~~~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=nl>candidate</span><span class=p>:</span> <span class=err>&#39;</span><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>   <span class=mi>12</span> <span class=o>|</span> <span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>      <span class=o>^~~~~</span>
</span></span></code></pre></td></tr></table></div></div><p>​ Some signatures that appear to be different from each other nonetheless can’t coexist. For example, remember the code we gave at first? Can I change the name of <code>swapReference()</code> to <code>swap()</code>? The answer is <strong>no</strong>! We&rsquo;ll explain it later when we talk about reference.</p><p>​ Keep in mind that the signature, not the function type, enables function overloading. For example, the following two declarations are incompatible:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>long</span> <span class=nf>gronk</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>float</span> <span class=n>m</span><span class=p>);</span>		<span class=c1>// same signatures
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=nf>gronk</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>float</span> <span class=n>m</span><span class=p>);</span>	<span class=c1>// hence not allowed
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nl>error</span><span class=p>:</span> <span class=n>ambiguating</span> <span class=k>new</span> <span class=n>declaration</span> <span class=n>of</span> <span class=err>&#39;</span><span class=kt>double</span> <span class=n>gronk</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>float</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>   <span class=mi>10</span> <span class=o>|</span> <span class=kt>double</span> <span class=n>gronk</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>float</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span>        <span class=o>^~~~~</span>
</span></span><span class=line><span class=cl><span class=nl>note</span><span class=p>:</span> <span class=n>old</span> <span class=n>declaration</span> <span class=err>&#39;</span><span class=kt>long</span> <span class=kt>int</span> <span class=n>gronk</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>float</span><span class=p>)</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=mi>9</span> <span class=o>|</span> <span class=kt>long</span> <span class=n>gronk</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>float</span> <span class=n>m</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>​ Therefore, C++ doesn’t permit you to overload gronk() in this fashion. You can have different return types, but only if the signatures are also different:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>long</span> <span class=nf>gronk</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>float</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>gronk</span><span class=p>(</span><span class=kt>double</span> <span class=n>n</span><span class=p>,</span> <span class=kt>float</span> <span class=n>m</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/c++/>C++</a>
<a href=/tags/learningnote/>LearningNote</a>
<a href=/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82/><div class=article-details><h2 class=article-title>实验室 C++ 基础课程 · 第二章第三节</h2></div></a></article><article><a href=/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%AC%E4%BA%8C%E8%8A%82/><div class=article-details><h2 class=article-title>实验室 C++ 基础课程 · 第二章第二节</h2></div></a></article><article><a href=/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%AC%E4%B8%80%E8%8A%82/><div class=article-details><h2 class=article-title>实验室 C++ 基础课程 · 第二章第一节</h2></div></a></article><article><a href=/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%BA%8C%E8%8A%82/><div class=article-details><h2 class=article-title>实验室 C++ 基础课程 · 第一章第二节</h2></div></a></article><article><a href=/p/%E5%AE%9E%E9%AA%8C%E5%AE%A4-c-%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%B8%80%E8%8A%82/><div class=article-details><h2 class=article-title>实验室 C++ 基础课程 · 第一章第一节</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=EvanWonghere/EvanWonghere.github.io data-repo-id=R_kgDOPzgwzg data-category=Announcements data-category-id=DIC_kwDOPzgwzs4Cvsti data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark_dimmed")}})()</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 EvanWong</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.31.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>